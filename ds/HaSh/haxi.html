<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" type="text/css" href="common.css">
    <link rel="stylesheet" href="viz-1.0.1.css">
    <link rel="stylesheet" href="visual.css">
    <link rel="stylesheet" href="drawgraph.css">
    <style>
    </style>
    <style>
        .execAction { padding: 8px 8px; }
        .err { padding: 5px 0px; }
        #actions-extras input {
            width: 55px;
            padding: 8px 8px 8px;
        }
         #insert-input input { width: 100px; }
        .create { bottom: 180px; }
        .insert { bottom: 150px; }
        .search { bottom: 90px; }
        .remove { bottom: 65px; }
    </style>
</head>
<body>
    <span id="title">
    <a id='title-DH' >闭散列</a>
    <a id='title-SC' >开散列</a>
  </span>

<div id="dark-overlay"></div>
<div id="status" class="panel"><p></p></div>
<div id="status-hide" class="panel-hide"><img src="" alt=">" title="show/hide status panel"/></div>
<div id="codetrace" class="panel">
    <p id="code1" style="padding-top: 10px;"></p>
    <p id="code2"></p>
    <p id="code3"></p>
    <p id="code4"></p>
    <p id="code5"></p>
    <p id="code6"></p>
    <p id="code7" style="padding-bottom: 10px;"></p>
</div>
<div id="codetrace-hide" class="panel-hide"><img src="" alt=">" title="show/hide codetrace panel"/></div>

<div id="left-bar"></div>
<div id="right-bar"></div>
<div id='viz'></div>
<div id='current-action' class='panel'></div>
<div id="overlay" hidden></div>
<div id="dropdown-temp-holder" hidden></div>
<div id="popup" hidden>
    <div id="popup-content"></div>
    <span id="hide-popup" hidden>X <u>Close</u></span>
</div>
<div id="actions" class="panel">
    <p id="create">Create(v)</p>
    <p id="insert">Insert(v)</p>
    <p id="search">Search(v)</p>
    <p id="remove">Remove(v)</p>
</div>
    <div class="create action-menu-pullout">
        <div id="create-input" class="new-menu-option"><p>空HaSh Table的大小 = <input type="number" id="v-create" title="Enter an Integer" autocomplete="off" min=0 max=29 value=1></p></div>
        <div id="create-go" class="execAction coloured-menu-option" onclick="createTable()"><p>确认</p></div>
        <div id="create-err" class="err"></div>
    </div>
   <div class="insert action-menu-pullout">
       <div id="insert-input" class="new-menu-option">插入的结点v = <input type="text" id="v-insert" title="Enter an Integer or comma-separated array of Integers" autocomplete="off" value="3,5,7" ></div>
    <div id="insert-go" class="execAction coloured-menu-option" onclick="insertInteger()"><p>确认</p></div>
    <div id="insert-err" class="err"></div>
</div>
    <div class="search action-menu-pullout">
        <div id="search-input" class="new-menu-option">搜索的结点v = <input type="number" id="v-search" title="Enter an Integer" autocomplete="off" min=0 value=1></div>
        <div id="search-go" class="execAction coloured-menu-option" onclick="searchInteger()"><p>确认</p></div>
        <div id="search-err" class="err"></div>
    </div>

    <div class="remove action-menu-pullout">
        <div id="remove-input" class="new-menu-option">删除的结点v = <input type="number" id="v-remove" title="Enter an Integer" autocomplete="off" min=0 value=""></div>
        <div id="remove-go" class="execAction coloured-menu-option" onclick="removeInteger()"><p>确认</p></div>
        <div id="remove-err" class="err"></div>
    </div>
</div>
    <center>
        <p><b>注意</b></p>
        <p>在插入正整数是以（在英文输入情况下的）逗号隔开</p>
        <p>在闭散列中插入的正整数应该小于等于创建的个数</p>
    </center>
    <script src="http://libs.baidu.com/jquery/1.9.0/jquery.js"></script>
    <script type="text/javascript">
    var PHP_DOMAIN = "";

    var colourArray = ["#52bc69", "#d65775"/*"#ed5a7d"*/, "#2ebbd1", "#d9513c", "#fec515", "#4b65ba", "#ff8a27", "#a7d41e"]; // green, pink, blue, red, yellow, indigo, orange, lime

    function disableScroll() { $('html').css('overflow', 'hidden'); }

    function enableScroll() { $('html').css('overflow', 'visible'); }

    function replaceAll(find, replace, str) { return str.replace(new RegExp(find, 'g'), replace); }

    function getColours() {
        var generatedColours = new Array();
        while (generatedColours.length < 4) {
            var n = (Math.floor(Math.random() * colourArray.length));
            if ($.inArray(n, generatedColours) == -1)
                generatedColours.push(n);
        }
        return generatedColours;
    }

    function isOn(value, position) {
        return (value>>position) & 1 === 1;
    }

    function customAlert(msg) {
        $('#custom-alert p').html(msg);
        var m = -1 * ($('#custom-alert').outerHeight()/2);
        $('#custom-alert').css('margin-top', m+'px');
        $('#dark-overlay').fadeIn(function() {
            $('#custom-alert').fadeIn(function() {
                setTimeout(function() {
                    $('#custom-alert').fadeOut(function() {
                        $('#dark-overlay').fadeOut();
                    });
                }, 1000);
            });
        });
    }

    function showLoadingScreen() {
        $('#loading-overlay').show();
        $('#loading-message').show();
    }

    function hideLoadingScreen() {
        $('#loading-overlay').hide();
    }

    function commonAction(retval, msg) {
        if (retval) { // mode == "exploration" && // now not only for exploration mode, but check if this opens other problems
            $('#current-action').show();
            $('#progress-bar').slider("option", "max", gw.getTotalIteration()-1);
            triggerRightPanels();
            isPlaying = true;
        }
    }

    function getQueryVariable(variable) {
        var query = window.location.search.substring(1);
        var vars = query.split('&');
        for (var i = 0; i < vars.length; i++) {
            var pair = vars[i].split('=');
            if (decodeURIComponent(pair[0]) == variable)
                return decodeURIComponent(pair[1]);
        }
        return "";
    }

    var generatedColours = getColours();
    var surpriseColour = colourArray[generatedColours[0]];
    var colourTheSecond = colourArray[generatedColours[1]];
    var colourTheThird = colourArray[generatedColours[2]];
    var colourTheFourth = colourArray[generatedColours[3]];

</script>
<script type="text/javascript" src="jquery-ui.min.js" integrity="sha256-VazP97ZCwtekAsvgPBSUwPFKdrwD3unUfSGVYrahUqU=" crossorigin="anonymous"></script>
    <script type="text/javascript" src="d3.min.js"></script>
    <script type="text/javascript" src="viz-1.0.3.js"></script>
<script type="text/javascript" src="graph_library-1.0.2.min.js"></script>
<script>
    window.onpopstate = function(event) {
        var slide = event.state['slide'];
        openSlide(slide, function() {
            runSlide(slide);
        });
    };

    function getUrlParameter(sParam) {
        var sPageURL = decodeURIComponent(window.location.search.substring(1)),
            sURLVariables = sPageURL.split('&'), sParameterName, i;

        for (i = 0; i < sURLVariables.length; i++) {
            sParameterName = sURLVariables[i].split('=');
            if (sParameterName[0] === sParam) return sParameterName[1] === undefined ? true : sParameterName[1];
        }
    };

    function pushState(slideValue) {
        var url = '/en/hashtable';
        if (typeof slideValue != 'undefined' && slideValue != null) url += '?slide=' + slideValue;
        window.history.pushState({slide: slideValue}, "slide " + slideValue, url);
    }

    function showPopup(callback) {
        $('#popup').fadeIn(100, callback);
    }

    function hidePopup(callback) {
        $('#popup').fadeOut(100, callback);
    }
    $(function() {
        var slide = getUrlParameter('slide');

        $.get('/hasvisited' + '/hashtable', function(data) {
            var hasVisited = data['hasvisited'] == '1';
            if (!hasVisited) {
                var postData = {
                    '_token': 'LeohGRVcJSXqmKGUMkUBoB9qNVPKvo9mT0JgrK0Q',
                    'page': '/hashtable'.substring(1),
                };

                $.post("/visitpage", postData, function(data) {
                    // non critical request...
                });

                if (typeof slide != undefined && slide != null) {
                    cur_slide = slide;
                }

                $("#mode-menu a").trigger("click");
            }
            else {
                if (typeof slide != undefined && slide != null) {
                    cur_slide = slide;
                    $('#mode-menu a').click();
                }
            }
        }).fail(function() {
            if (typeof slide != undefined && slide != null) {
                cur_slide = slide;
                $('#mode-menu a').click();
            }
        });

        $('.mcq-submit').click(function() {
            var questionId = parseInt($(this).attr('id').split('-')[1]);
            var answer = $('#mcq-answer-' + questionId).val();
            var userAnswer = $('input[type=radio][name=mcq-'+questionId+'-choice]:checked').val();

            if (answer === userAnswer) {
                $('#answer-status-' + questionId).html('<font color="green"><b>Correct!</b></font>');
            }
            else {
                $('#answer-status-' + questionId).html('<font color="red"><b>Wrong Answer! Try again...</b></font>');
            }
            $('#answer-status-' + questionId).show();
            setTimeout(function() {
                $('#answer-status-' + questionId).fadeOut(1000);
            }, 1000);
        });

        $('.msq-submit').click(function() {
            var questionId = parseInt($(this).attr('id').split('-')[1]);
            var answer = $('#msq-answer-' + questionId).val();

            var answers = [];
            $('input[type=checkbox][class=msq-choice]:checked').each(function() {
                answers.push($(this).attr('id').split('-')[3]);
            });
            answers.sort();
            var userAnswer = answers.join(',');
            if (answer === userAnswer) {
                $('#answer-status-' + questionId).html('<font color="green">Correct!</font>');
            }
            else {
                $('#answer-status-' + questionId).html('<font color="red">Wrong Answer! Try again...</font>');
            }
            $('#answer-status-' + questionId).show();
            setTimeout(function() {
                $('#answer-status-' + questionId).fadeOut(1000);
            }, 1000);
        });

        $('select.lecture-dropdown').change(function() {
            var nextSlide = $(this).val();
            openSlide(nextSlide, function() {
                runSlide(nextSlide);
                pushState(nextSlide);
            });
        });

        $('#hide-popup').click(function() {
            hidePopup();
        });

        $('#popup').hover(function() {
            $('#hide-popup').show();
        }, function() {
            $('#hide-popup').hide();
        });
        // temporary quick fix for Google Chrome Aug 2016 issue..., put at last part so that everything else has been loaded
        setTimeout(function(){ document.body.style.zoom = "100.1%"; }, 500);
        setTimeout(function(){ document.body.style.zoom = "100%"; }, 600);
    });
    function adjustPopupToImageSize() {
        var width = $('#popup-image').prop('width');
        var height = $('#popup-image').prop('height');
        $('#popup').width(width + 20);
        $('#popup').height(height + 20);
        if (width == 0 && height == 0) {
            setTimeout(adjustPopupToImageSize, 200);
        } else {
            showPopup();
        }
    }

</script>

<script>
function ENTER_LECTURE_MODE() {}
function ENTER_EXPLORE_MODE() {}
function CUSTOM_ACTION(action, data, mode) {}
</script>
<script type="text/javascript">
    var HashTable = function() {
        var self = this;
        var gw = new GraphWidget();
        var activeStatus = "-";
        var maxHashTableSize = 29; // we only allow primes up to 27
        var primes = [3, 5, 7, 11, 13, 17, 19,21,23,25,27]; // OK, only these 5 primes are actually within our range of allowed Hash Table size
        var EMPTY = -1; // use -1 to indicate EMPTY element
        var DELETED = -2; // use -2 to indicate DELETED element
        var HT;  // HT: the Array that represents the state of the Hash Table in Open Addressing
        var HT_SC; // HT_SC: Adjacency List like structure to represent the state of the Hash Table in Separate Chaining
        var N = 4; // number of elements actually present in the hash table

        this.setActiveStatus = function(newActiveStatus) {
            if (activeStatus != newActiveStatus) {
                activeStatus = newActiveStatus;
                if (activeStatus == "SC") { // Separate Chaining
                    HT_SC = [[], [], [], [], [], [], []];
                    N = 0;
                    initSC(HT_SC);
                }
                else { // Open Addressing
                  if (activeStatus == "DH") {
                        HT = [EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY];
                        N = 0;
                    }
                    init(HT);
                }
            }
        }

        this.getActiveStatus = function() { return activeStatus; }
        this.getGraphWidget = function() { return gw; }
        this.createTable = function(sz) {
            if (sz > maxHashTableSize) {
                $('#create-err').html('HaSh Table最大为' + maxHashTableSize);
                return false;
            }
            else if (sz < 3) {
                // Sorry, Hash Table size should be ≥
                $('#create-err').html('HaSh Table 最小为 ' + "3");
                return false;
            }

            N = 0;
            if (activeStatus == "SC") { // Separate Chaining
                HT_SC = new Array(sz);
                for (var i = 0; i < sz; i++) HT_SC[i] = [];
                initSC(HT_SC);
            }
            else if (activeStatus != "SC") { // NOT Separate Chaining means Open Addressing where we cannot have big table
                HT = new Array(sz);
                for (var i = 0; i < sz; i++) HT[i] = EMPTY;
                init(HT);
            }
        };

        this.createTableSpecial = function(_HT) {
            HT = _HT;
            N = 0;
            for (var i = 0; i < HT.length; i++) if (HT[i] != EMPTY) N++;
            init(HT);
        }

        this.generate = function(arr) {
            if (arr.length > maxHashTableSize) {
                // Sorry, maximum allowed Hash Table size is
                $('#create-err').html('\'HaSh Table最大为 ' + maxHashTableSize);
                return;
            }
            if (arr.length < 3) {
                // Sorry, Hash Table size should be ≥
                $('#create-err').html('\'HaSh Table最小为 ' + "3");
                return;
            }

            for (var i = 0; i < arr.length; i++) {
                arr[i] = parseInt(arr[i]);
                if (arr[i] < EMPTY) {
                    $('#create-err').html('\'HaSh Table中应为正整数'); // put in variable soon
                    return; // can't create this hashtable
                }
            }
            init(arr);
        };

        function init(initArr) {
            var scale = 1000 / (initArr.length-1);
            try {
                for (var i = 0; i < 20*8; i++) {
                    gw.removeVertex(i);
                    gw.removeEdge(i);
                }
            }
            catch (e) { // do nothing if that vertex actually not yet exist

            }
            HT = new Array(); // destroy previous content first...
            for (var i = 0; i < initArr.length; i++) {
                HT[i] = initArr[i];
                gw.addVertex(50 + i*scale, 100, (HT[i] == EMPTY ? '' : (HT[i] == DELETED ? 'DEL' : HT[i])), i, true, "V" + i);
            }
        }

        function initSC(arr) {
            var M = arr.length;
            var scale = 1000/ (M-1);
            try {
                for (var i = 0; i < 20*8; i++) {
                    gw.removeVertex(i);
                    gw.removeEdge(i);
                }
            }
            catch (e) { // do nothing if that vertex actually not yet exist

            }

            for (var i = 0; i < M; i++) gw.addVertex(50 + i*scale, 100, "H", i*7, true, "V" + i);
            N = 0;
            for (var i = 0; i < M; i++) {
                for (var j = 0; j < arr[i].length; j++) {
                    gw.addVertex(80 + i*scale, 100 + (j+1)*70, arr[i][j], i*7+(j+1), 1, "");
                    gw.addEdge(i*7+j, i*7+(j+1), i*7+(j+1), (j == 0) ? EDGE_TYPE_DE : EDGE_TYPE_UDE, 1, true);
                }
            }
        }

        this.search = function(key, callback) {
            var stateList = [];
            var vertexTraversed = {};
            var edgeTraversed = {};
            var cs;

            if (key < 0 ) {
                cs = createState(vertexTraversed, edgeTraversed);
                cs["status"] = 'key = {key}, it must be >0 in this visualization.<br>-1 = empty cell (blank) and -2 = deleted item.'.replace("{key}", key);
                stateList.push(cs);
            }
            else {
                var i = key%(HT.length), base = i;
                var i_next;
                var jump = 1;
                var step = 1;
                var k = 5, smallerPrime = primes[k]; // start from 17
                while (smallerPrime >= HT.length)
                    smallerPrime = primes[k--];
                var secondary = smallerPrime - key%smallerPrime; // so it will always be positive
                var strategy = "linear probing";

                cs = createState(vertexTraversed, edgeTraversed);
                // key = {key} is hashed to i = base = {key}%{length} = {i}.
                cs["status"] = 'key = {key} 在HaSh Table中的位置是根据{key}%{length} = {i}.'.replace("{key}", key).replace("{key}", key).replace("{length}", HT.length).replace("{i}", i);
                cs["vl"][i]["state"] = VERTEX_HIGHLIGHTED;
                cs["lineNo"] = 1;
                stateList.push(cs);
                vertexTraversed[i] = true; // this is traversed in future iteration

                while (true) {
                    if (HT[i] == EMPTY) { // Not Found
                        cs = createState(vertexTraversed, edgeTraversed);
                        cs["status"] = 'HT[{i}] 是空的.<br> key = {key} 在 Hash Table中没有找到 .'.replace("{i}", i).replace("{key}", key);
                        cs["vl"][i]["state"] = VERTEX_HIGHLIGHTED;
                        cs["lineNo"] = 3;
                        stateList.push(cs);
                        break;
                    }
                    else if (HT[i] == key) { // Found
                        cs = createState(vertexTraversed, edgeTraversed);
                        cs["status"] = 'HT[{i}] = {key}.<br> key = {key} 在 Hash Table 的V{i}中找到.'.replace("{i}", i).replace("{key}", key).replace("{key}", key).replace("{i}", i);
                        cs["vl"][i]["state"] = VERTEX_HIGHLIGHTED;
                        cs["lineNo"] = 4;
                        stateList.push(cs);
                        break;
                    }
                    else {
                        if (step == HT.length) {
                            cs = createState(vertexTraversed, edgeTraversed);
                            // After probing all possibilities, key = {key} is not found in Hash Table HT.
                            cs["status"] = 'key = {key}在Hash Table 中没有找到.'.replace("{key}", key);
                            stateList.push(cs);
                            break;
                        }
                        if (activeStatus == "DH") {
                            jump = secondary;
                            strategy = "double hashing";
                        }

                        i_next = (base + step*jump) % HT.length;

                        cs = createState(vertexTraversed, edgeTraversed);
                        cs["status"] = 'HT[{i}] = {val} != key.<br>Use {strategy} to check the next index i_next = ({base}+{step}*{jump})%{length} = {i_next}.'
                            .replace("{i}", i).replace("{val}", HT[i]).replace("{strategy}", strategy)
                            .replace("{base}", base).replace("{step}", step).replace("{jump}", jump).replace("{length}", HT.length).replace("{i_next}", i_next);
                        cs["vl"][i_next]["state"] = VERTEX_HIGHLIGHTED;
                        cs["lineNo"] = 5;
                        stateList.push(cs);
                        vertexTraversed[i_next] = true; // this is traversed in future iteration
                        i = i_next;
                        step++;
                    }
                }
            }

            gw.startAnimation(stateList, callback);
            populatePseudocode(0);
            return true;
        }

        this.searchSC = function(key, callback) {
            var stateList = [];
            var vertexTraversed = {};
            var edgeTraversed = {};
            var cs;

            if (key < 0 ) {
                cs = createStateSC(vertexTraversed, edgeTraversed);
                cs["status"] = 'key = {key}, it must be between >0 in this visualization.<br>-1 = empty cell (blank) and -2 = deleted item.'.replace("{key}", key);
                stateList.push(cs);
            }
            else {
                var M = HT_SC.length;
                var i = key%M;
                var j = 0;

                cs = createStateSC(vertexTraversed, edgeTraversed);
                // key = {key} is hashed to i = base = {key}%{length} = {i}.
                cs["status"] = 'key = {key} 在HaSh Table的位置是根据 {key}%{length} = {i}.'.replace("{key}", key).replace("{key}", key).replace("{length}", M).replace("{i}", i);
                cs["vl"][i*7]["state"] = VERTEX_HIGHLIGHTED;
                cs["lineNo"] = 1;
                stateList.push(cs);
                vertexTraversed[i*7] = true; // this is traversed in future iteration

                for (var j = 0; j < HT_SC[i].length; j++) {
                    cs = createStateSC(vertexTraversed, edgeTraversed);
                    cs["status"] = 'Checking this vertex';
                    cs["vl"][i*7+(j+1)]["state"] = VERTEX_HIGHLIGHTED;
                    cs["lineNo"] = [2, 3];
                    stateList.push(cs);
                    vertexTraversed[i*7+(j+1)] = true; // this is traversed in future iteration
                    if (HT_SC[i][j] == key) {
                        cs = createStateSC(vertexTraversed, edgeTraversed);
                        cs["status"] = '{key} 在 Hash Table中找到'.replace("{key}", key);
                        cs["vl"][i*7+(j+1)]["state"] = VERTEX_HIGHLIGHTED;
                        cs["lineNo"] = [4];
                        stateList.push(cs);
                        break;
                    }
                }

                if (j == HT_SC[i].length) { // not found
                    cs = createStateSC(vertexTraversed, edgeTraversed);
                    cs["status"] = '{key}在 Hash Table中没有找到'.replace("{key}", key);
                    cs["lineNo"] = 5;
                    stateList.push(cs);
                }
            }

            gw.startAnimation(stateList, callback);
            populatePseudocode(3);
            return true;
        }

        this.insert = function(keys, callback) {
            var stateList = [];
            var vertexTraversed = {};
            var edgeTraversed = {};
            var cs;

            var the_keys = keys.split(",");
            for (idx in the_keys) {
                key = parseInt(the_keys[idx]);

                if (key < 0 ) {
                    cs = createState(vertexTraversed, edgeTraversed);
                    cs["status"] = 'key = {key}, it must be >0 in this visualization.<br>-1 = empty cell (blank) and -2 = deleted item.'.replace("{key}", key);
                    stateList.push(cs);
                }
                else if (HT.indexOf(key) != -1) {
                    cs = createState(vertexTraversed, edgeTraversed);
                    cs["status"] = 'key = {key} is already in the Hash Table.<br>We prevent insertion of duplicate keys.'.replace("{key}", key);
                    stateList.push(cs);
                }
                else {
                    if (N == HT.length) { // one item before full (if we allow full, our search can get into infinite loop)
                        cs = createState(vertexTraversed, edgeTraversed);
                        cs["status"] = 'the Hash Table HT is nearly full (load factor too high).<br>We cannot insert a new integer.';
                        cs["lineNo"] = 1;
                        stateList.push(cs);
                    }
                    else { // not yet full, do the insertion
                        var i = key%(HT.length), base = i;
                        var i_next;
                        var jump = 1;
                        var step = 1;
                        var k = 5, smallerPrime = primes[k]; // start from 17
                        while (smallerPrime >= HT.length)
                            smallerPrime = primes[k--];
                        var secondary = smallerPrime - key%smallerPrime; // so it will always be positive
                        var strategy = "linear probing";

                        cs = createState(vertexTraversed, edgeTraversed);
                        cs["status"] = 'The hash table is not yet full.<br>key = {key} is hashed to i = base = {key}%{length} = {i}.'.replace("{key}", key).replace("{key}", key).replace("{length}", HT.length).replace("{i}", i);
                        cs["vl"][i]["state"] = VERTEX_HIGHLIGHTED;
                        cs["lineNo"] = 2;
                        stateList.push(cs);
                        vertexTraversed[i] = true; // this is traversed in future iteration

                        while (HT[i] > 0 && step < HT.length) {
                            if (activeStatus == "DH") {
                                jump = secondary;
                                strategy = "double hashing";
                            }
                            i_next = (base + step*jump) % HT.length;
                            var special = (HT[i] == key ? '&nbsp;(actually a duplicate key)' : ""); // ' (actually a duplicate key)'
                            cs = createState(vertexTraversed, edgeTraversed);
                            cs["status"] = 'HT[{i}] = {val} is occupied{special}.<br>Use {strategy} to check the next index i_next ({base}+{step}*{jump})%{length} = {i_next}.'
                                .replace("{i}", i).replace("{val}", HT[i]).replace("{special}", special)
                                .replace("{strategy}", strategy).replace("{base}", base).replace("{step}", step).replace("{jump}", jump).replace("{length}", HT.length).replace("{i_next}", i_next);
                            cs["vl"][i_next]["state"] = VERTEX_HIGHLIGHTED;
                            cs["lineNo"] = 3;
                            stateList.push(cs);
                            vertexTraversed[i_next] = true; // this is traversed in future iteration
                            i = i_next;
                            step++;
                        }

                        if (step == HT.length) {
                            cs = createState(vertexTraversed, edgeTraversed);
                            cs["status"] = 'After {step} probe steps, we still cannot find an insertion point.<br>Reporting failure...'.replace("{step}", step);
                            stateList.push(cs);
                        }
                        else {
                            HT[i] = key;
                            N++;
                            cs = createState(vertexTraversed, edgeTraversed);
                            cs["status"] = 'Found insertion point: Insert {key} at HT[{i}].<br>There are now {N} items in the Hash Table.'.replace("{key}", key).replace("{i}", i).replace("{N}", N);
                            cs["vl"][i]["state"] = VERTEX_TRAVERSED;
                            cs["lineNo"] = 4;
                            stateList.push(cs);
                        }
                    }
                }
            }

            gw.startAnimation(stateList, callback);
            populatePseudocode(1);
            return true;
        }

        this.insertSC = function(keys, callback) {
            var stateList = [];
            var vertexTraversed = {};
            var edgeTraversed = {};
            var cs;

            var the_keys = keys.split(",");
            for (idx in the_keys) {
                key = parseInt(the_keys[idx]);

                if (key < 0 ) {
                    cs = createStateSC(vertexTraversed, edgeTraversed);
                    cs["status"] = 'key = {key}, it must be >0 in this visualization.<br>-1 = empty cell (blank) and -2 = deleted item.'.replace("{key}", key);
                    stateList.push(cs);
                }
                else {
                    var already_inside = false;
                    var M = HT_SC.length;
                    for (var i = 0; i < M; i++)
                        if (HT_SC[i].indexOf(key) != -1)
                            already_inside = true;

                    if (already_inside) {
                        cs = createStateSC(vertexTraversed, edgeTraversed);
                        cs["status"] = 'key = {key} is already in the Hash Table.<br>We prevent insertion of duplicate keys.'.replace("{key}", key);
                        stateList.push(cs);
                    }
                    else {
                        var i = key%M;
                        cs = createStateSC(vertexTraversed, edgeTraversed);
                        cs["status"] = 'The hash table is not yet full.<br>key = {key} is hashed to i = base = {key}%{length} = {i}.'.replace("{key}", key).replace("{key}", key).replace("{length}", M).replace("{i}", i);
                        cs["vl"][i*7]["state"] = VERTEX_HIGHLIGHTED;
                        cs["lineNo"] = 1;
                        stateList.push(cs);
                        vertexTraversed[i*7] = true; // this is traversed in future iteration

                        if (HT_SC[i].length == 6) {
                            cs = createStateSC(vertexTraversed, edgeTraversed);
                            cs["status"] = 'Sorry, due to the limitation of this visualization<br>We do not allow any more extension to linked list {i}'.replace("{i}", i);
                            cs["vl"][i*7]["state"] = VERTEX_HIGHLIGHTED;
                            cs["lineNo"] = 2;
                            stateList.push(cs);
                        }
                        else {
                            HT_SC[i].push(key); // put at the back of this doubly linked list (assume that we have access to tail pointer)
                            cs = createStateSC(vertexTraversed, edgeTraversed);
                            cs["status"] = 'We append {key} to the back of Doubly Linked List {i}<br>This is O(1) with tail pointer'.replace("{key}", key).replace("{i}", i);
                            cs["vl"][i*7+(HT_SC[i].length-1)]["state"] = VERTEX_HIGHLIGHTED;
                            cs["vl"][i*7+(HT_SC[i].length)]["state"] = VERTEX_HIGHLIGHTED;
                            cs["lineNo"] = 3;
                            stateList.push(cs);
                        }
                    }
                }
            }

            gw.startAnimation(stateList, callback);
            populatePseudocode(4);
            return true;
        }

        this.remove = function(key, callback) {
            var stateList = [];
            var vertexTraversed = {};
            var edgeTraversed = {};
            var cs;

            if (key < 0 ) {
                cs = createState(vertexTraversed, edgeTraversed);
                cs["status"] = 'key = {key}, it must be between >0 in this visualization.<br>-1 = empty cell (blank) and -2 = deleted item.'.replace("{key}", key);
                stateList.push(cs);
            }
            else {
                var i = key % (HT.length), base = i;
                var i_next;
                var jump = 1;
                var step = 1;
                var k = 5, smallerPrime = primes[k]; // start from 17
                while (smallerPrime >= HT.length)
                    smallerPrime = primes[k--];
                var secondary = smallerPrime - key%smallerPrime; // so it will always be positive
                var strategy = "linear probing";

                cs = createState(vertexTraversed, edgeTraversed);
                // key = {key} is hashed to i = base = {key}%{length} = {i}.
                cs["status"] = 'key = {key} is hashed to i = base = {key}%{length} = {i}.'.replace("{key}", key).replace("{key}", key).replace("{length}", HT.length).replace("{i}", i);
                cs["vl"][i]["state"] = VERTEX_HIGHLIGHTED;
                cs["lineNo"] = 1;
                stateList.push(cs);
                vertexTraversed[i] = true; // this is traversed in future iteration

                while (true) {
                    if (HT[i] == EMPTY) { // Not Found
                        cs = createState(vertexTraversed, edgeTraversed);
                        cs["status"] = 'HT[{i}] is empty.<br>Therefore key = {key} is not found in Hash Table HT.'.replace("{i}", i).replace("{key}", key);
                        cs["vl"][i]["state"] = VERTEX_HIGHLIGHTED;
                        cs["lineNo"] = 3;
                        stateList.push(cs);
                        break;
                    }
                    else if (HT[i] == key) { // Found
                        cs = createState(vertexTraversed, edgeTraversed);
                        cs["status"] = 'HT[{i}] = {key}.<br>Therefore key = {key} is found in Hash Table HT at index {i}.'.replace("{i}", i).replace("{key}", key).replace("{key}", key).replace("{i}", i);
                        cs["vl"][i]["state"] = VERTEX_HIGHLIGHTED;
                        cs["lineNo"] = 4;
                        stateList.push(cs);

                        HT[i] = DELETED;
                        N--;
                        cs = createState(vertexTraversed, edgeTraversed);
                        cs["status"] = 'Now we mark HT[{i}] as deleted<br>There are now {N} items in the Hash Table.'.replace("{i}", i).replace("{N}", N);
                        cs["vl"][i]["state"] = VERTEX_HIGHLIGHTED;
                        cs["lineNo"] = 5;
                        stateList.push(cs);
                        break;
                    }
                    else {
                        if (activeStatus == "DH") {
                            jump = secondary;
                            strategy = "double hashing";
                        }
                        i_next = (base + step * jump) % HT.length;

                        cs = createState(vertexTraversed, edgeTraversed);
                        cs["status"] = 'HT[{i}] = {val} != key.<br>Use {strategy} to check the next index i_next = ({base}+{step}*{jump})%{length} = {i_next}.'
                            .replace("{i}", i).replace("{val}", HT[i])
                            .replace("{strategy}", strategy).replace("{base}", base).replace("{step}", step).replace("{jump}", jump).replace("{length}", HT.length).replace("{i_next}", i_next);
                        cs["vl"][i_next]["state"] = VERTEX_HIGHLIGHTED;
                        cs["lineNo"] = 6;
                        stateList.push(cs);
                        vertexTraversed[i_next] = true; // this is traversed in future iteration
                        i = i_next;
                        step++;
                    }
                }
            }

            gw.startAnimation(stateList, callback);
            populatePseudocode(2);
            return true;
        }

        this.removeSC = function(key, callback) {
            var stateList = [];
            var vertexTraversed = {};
            var edgeTraversed = {};
            var cs;

            if (key < 0 ) {
                cs = createStateSC(vertexTraversed, edgeTraversed);
                cs["status"] = 'key = {key}, it must be between >0in this visualization.<br>-1 = empty cell (blank) and -2 = deleted item.'.replace("{key}", key);
                stateList.push(cs);
            }
            else {
                var M = HT_SC.length;
                var i = key%M;
                var j = 0;

                cs = createStateSC(vertexTraversed, edgeTraversed);
                // key = {key} is hashed to i = base = {key}%{length} = {i}.
                cs["status"] = 'key = {key} is hashed to i = base = {key}%{length} = {i}.'.replace("{key}", key).replace("{key}", key).replace("{length}", M).replace("{i}", i);
                cs["vl"][i*7]["state"] = VERTEX_HIGHLIGHTED;
                cs["lineNo"] = 1;
                stateList.push(cs);
                vertexTraversed[i*7] = true; // this is traversed in future iteration

                var found_and_deleted = false;
                for (var j = 0; j < HT_SC[i].length; j++) {
                    cs = createStateSC(vertexTraversed, edgeTraversed);
                    cs["status"] = 'Checking this vertex';
                    cs["vl"][i*7+(j+1)]["state"] = VERTEX_HIGHLIGHTED;
                    cs["lineNo"] = [2, 3];
                    stateList.push(cs);
                    vertexTraversed[i*7+(j+1)] = true; // this is traversed in future iteration
                    if (HT_SC[i][j] == key) {
                        cs = createStateSC(vertexTraversed, edgeTraversed);
                        cs["status"] = '{key} is found in Hash Table'.replace("{key}", key).replace("{i}", i);
                        cs["vl"][i*7+(j+1)]["state"] = VERTEX_HIGHLIGHTED;
                        cs["lineNo"] = [4];
                        stateList.push(cs);

                        HT_SC[i].splice(j, 1);
                        delete vertexTraversed[i*7+(j+1)];
                        cs = createStateSC(vertexTraversed, edgeTraversed);
                        cs["status"] = 'It is removed from list {i} in O(1+&alpha;)<br>Deletion is fast if we use Doubly Linked List'.replace("{key}", key).replace("{i}", i);
                        cs["lineNo"] = [4];
                        stateList.push(cs);

                        found_and_deleted = true;
                        break;
                    }
                }

                if (!found_and_deleted) { // not found
                    cs = createStateSC(vertexTraversed, edgeTraversed);
                    cs["status"] = '{key} is not found in Hash Table'.replace("{key}", key);
                    cs["lineNo"] = 5;
                    stateList.push(cs);
                }
            }

            gw.startAnimation(stateList, callback);
            populatePseudocode(5);
            return true;
        }

        function createState(vertexTraversed, edgeTraversed) {
            if (vertexTraversed == null || vertexTraversed == undefined || !(vertexTraversed instanceof Object))
                vertexTraversed = {};
            if (edgeTraversed == null || edgeTraversed == undefined || !(edgeTraversed instanceof Object))
                edgeTraversed = {};

            var scale = 1000 / (HT.length-1);

            var state = {
                "vl": {},
                "el": {}
            };

            for (var i = 0; i < HT.length; i++) {
                state["vl"][i] = {};
                state["vl"][i]["cx"] = 50 + i*scale;
                state["vl"][i]["cy"] = 100;
                state["vl"][i]["text"] = (HT[i] == EMPTY ? '' : (HT[i] == DELETED ? 'DEL' : HT[i]));
                state["vl"][i]["extratext"] = "i:" + i;
                state["vl"][i]["state"] = VERTEX_DEFAULT;
            }

            for (var key in vertexTraversed)
                state["vl"][key]["state"] = VERTEX_TRAVERSED;

            return state;
        }

        function createStateSC(vertexTraversed, edgeTraversed) {
            if (vertexTraversed == null || vertexTraversed == undefined || !(vertexTraversed instanceof Object))
                vertexTraversed = {};
            if (edgeTraversed == null || edgeTraversed == undefined || !(edgeTraversed instanceof Object))
                edgeTraversed = {};

            var M = HT_SC.length;
            var scale = 1000 / (M-1);
            var state = {
                "vl": {},
                "el": {}
            };

            for (var i = 0; i < M; i++) {
                state["vl"][i*7] = {};
                state["vl"][i*7]["cx"] = 50 + i*scale;
                state["vl"][i*7]["cy"] = 100;
                state["vl"][i*7]["text"] = "H";
                state["vl"][i*7]["extratext"] = "V" + i;
                state["vl"][i*7]["state"] = VERTEX_DEFAULT;
            }

            for (var i = 0; i < M; i++) {
                for (var j = 0; j < HT_SC[i].length; j++) {
                    state["vl"][i*7+(j+1)] = {};
                    state["vl"][i*7+(j+1)]["cx"] = 80 + i*scale;
                    state["vl"][i*7+(j+1)]["cy"] = 100 + (j+1)*70;
                    state["vl"][i*7+(j+1)]["text"] = HT_SC[i][j];
                    state["vl"][i*7+(j+1)]["state"] = VERTEX_DEFAULT;

                    state["el"][i*7+(j+1)] = {};
                    state["el"][i*7+(j+1)]["vertexA"] = i*7+j;
                    state["el"][i*7+(j+1)]["vertexB"] = i*7+(j+1);
                    state["el"][i*7+(j+1)]["type"] = (j == 0) ? EDGE_TYPE_DE : EDGE_TYPE_UDE;
                    state["el"][i*7+(j+1)]["weight"] = 1;
                    state["el"][i*7+(j+1)]["state"] = EDGE_DEFAULT;
                    state["el"][i*7+(j+1)]["animateHighlighted"] = false;
                }
            }

            for (var key in vertexTraversed)
                state["vl"][key]["state"] = VERTEX_TRAVERSED;

            return state;
        }

        function populatePseudocode(act) {
            var jump = '1';
            if (activeStatus == "DH")
                jump = 'sec';

            switch (act) {
                case 0: // search
                    $('#code1').html('step = 0; i = base = key%HT.length;');
                    $('#code2').html('while (true)');
                    $('#code3').html('&nbsp&nbspif (HT[i] == EMPTY) return "not found"');
                    $('#code4').html('&nbsp&nbspelse if (HT[i] == key) return "found at index i"');
                    $('#code5').html('&nbsp;&nbsp;else step++; i = (base+step*{jump})%HT.length'.replace('{jump}', jump));
                    $('#code6').html((activeStatus == 'DH' ? '// sec = prime - key%prime' : ''));
                    $('#code7').html('');
                    break;
                case 1: // insert
                    $('#code1').html('if N+1 == M, prevent insertion');
                    $('#code2').html('step = 0; i = base = key%HT.length;');
                    $('#code3').html('while (HT[i] != EMPTY || HT[i] != DELETED)');
                    $('#code4').html('&nbsp;&nbsp;step++; i = (base+step*{jump})%HT.length'.replace('{jump}', jump));
                    $('#code5').html('found insertion point, insert key at HT[i]');
                    $('#code6').html((activeStatus == 'DH' ? '// sec = prime - key%prime' : ''));
                    $('#code7').html('');
                    break;
                case 2: // remove
                    $('#code1').html('step = 0; i = base = key%HT.length;');
                    $('#code2').html('while (true)');
                    $('#code3').html('&nbsp&nbspif (HT[i] == EMPTY) break // &nbsp&nbspif (HT[i] == EMPTY) break // key not found');
                    $('#code4').html('&nbsp&nbspelse if (HT[i] == key) // &nbsp&nbspelse if (HT[i] == key)');
                    $('#code5').html('&nbsp&nbsp&nbsp&nbspHT[i] = DELETED, break // &nbsp;&nbsp;&nbsp;&nbsp;HT[i] = DELETED');
                    $('#code6').html('&nbsp&nbspelse step++; i = (base+step*{jump})%HT.length'.replace('{jump}', jump));
                    $('#code7').html((activeStatus == 'DH' ? '// sec = prime - key%prime' : ''));
                    break;
                case 3: // search SC
                    $('#code1').html('i = key%HT.length;');
                    $('#code2').html('for j = 0 to HT_SC[i].length');
                    $('#code3').html('&nbsp&nbspif (HT_SC[i][j] == key)');
                    $('#code4').html('&nbsp&nbsp&nbsp&nbspreturn "found at index i"');
                    $('#code5').html('return "not found"');
                    $('#code6').html('');
                    $('#code7').html('');
                    break;
                case 4: // insert SC
                    $('#code1').html('i = key%HT.length;');
                    $('#code2').html('if HT_SC[i].length == 6, prevent insertion');
                    $('#code3').html('insert key to the back of this list i');
                    $('#code4').html('');
                    $('#code5').html('');
                    $('#code6').html('');
                    $('#code7').html('');
                    break;
                case 5: // remove SC
                    $('#code1').html('i = key%HT.length;');
                    $('#code2').html('for j = 0 to HT_SC[i].length');
                    $('#code3').html('&nbsp&nbspif (HT_SC[i][j] == key)');
                    $('#code4').html('&nbsp&nbsp&nbsp&nbspremove key from list i');
                    $('#code5').html('// do nothing, not found');
                    $('#code6').html('');
                    $('#code7').html('');
                    break;
            }
        }
    }

    var actionsWidth = 150;
    var statusCodetraceWidth = 420;

    var isCreateOpen = false;
    var isSearchOpen = false;
    var isInsertOpen = false;
    var isRemoveOpen = false;

    function openCreate() {
        $(".create").css("bottom", "146px");
        $('#createfixedsize-input').hide();
        $('#createuserdefined-input').hide();
        if (!isCreateOpen) {
            $('.create').fadeIn('fast');
            isCreateOpen = true;
        }
    }

    function closeCreate() {
        if (isCreateOpen) {
            $('.create').fadeOut('fast');
            $('#create-err').html("");
            isCreateOpen = false;
        }
    }

    function openSearch() {
        if (!isSearchOpen) {
            $('.search').fadeIn('fast');
            isSearchOpen = true;
        }
    }

    function closeSearch() {
        if (isSearchOpen) {
            $('.search').fadeOut('fast');
            $('#search-err').html("");
            isSearchOpen = false;
        }
    }

    function openInsert() {
        $(".insert").css("bottom", "92px");
        $('#insertkth-input').hide();
        $('#inserthead-input').hide();
        $('#inserttail-input').hide();
        if (!isInsertOpen) {
            $('.insert').fadeIn('fast');
            isInsertOpen = true;
        }
    }

    function closeInsert() {
        if (isInsertOpen) {
            $('.insert').fadeOut('fast');
            $('#insert-err').html("");
            isInsertOpen = false;
        }
    }

    function openRemove() {
        $(".remove").css("bottom", "65px");
        $('#removekth-input').hide();
        if (!isRemoveOpen) {
            $('.remove').fadeIn('fast');
            isRemoveOpen = true;
        }
    }

    function closeRemove() {
        if (isRemoveOpen) {
            $('.remove').fadeOut('fast');
            $('#remove-err').html("");
            isRemoveOpen = false;
        }
    }

    function hideEntireActionsPanel() {
        closeCreate();
        closeSearch();
        closeInsert();
        closeRemove();
        hideActionsPanel();
    }

    function AbbreviateTitle() {

        $('#title-DH').text("DH");
        $('#title-SC').text("SC");
    }
    $('#title-DH').click(function() {
        if (isPlaying) stop();
        htw.setActiveStatus("DH");
        AbbreviateTitle();
        $('#title-DH').text('Double Hashing');
    });
    $('#title-SC').click(function() {
        if (isPlaying) stop();
        htw.setActiveStatus("SC");
        AbbreviateTitle();
        $('#title-SC').text('Separate Chaining');
    });

    // local
    $('#play').hide();
    var htw = new HashTable();
    var gw = htw.getGraphWidget();

    $(function() {
        var four_modes = [ "DH", "SC"];
        $('#title-'+four_modes[Math.floor(Math.random()*4)]).click(); // randomly open one of the four default example every time

        var hashMode = getQueryVariable("mode");
        if (hashMode.length > 0) {
            $('#title-'+hashMode).click();
        }
        var createHT = getQueryVariable("create");
        if (createHT.length > 0) {
            var newHT = createHT.split(",");
            if (newHT.length == 1)
                htw.createTable(createHT);
            else
                htw.generate(newHT);
        }
        var insert = getQueryVariable("insert");
        if (insert.length > 0) {
            $('#v-insert').val(insert);
            openInsert();
        }
        var remove = getQueryVariable("remove");
        if (remove.length > 0) {
            $('#v-remove').val(remove);
            openRemove();
        }

        $('#create').click(function() {
            closeSearch();
            closeInsert();
            closeRemove();
            openCreate();
        });
        $('#search').click(function() {
            closeCreate();
            closeInsert();
            closeRemove();
            openSearch();
        });
        $('#insert').click(function() {
            closeCreate();
            closeSearch();
            closeRemove();
            openInsert();
        });
        $('#remove').click(function() {
            closeCreate();
            closeSearch();
            closeInsert();
            openRemove();
        });
    });

    function createTable() {
        if (isPlaying) stop();
        var input = parseInt($('#v-create').val());
        if (htw.createTable(input)) {
            $('#progress-bar').slider("option", "max", 0);
            closeCreate();
            isPlaying = false;
        }
        hideStatusPanel();
        hideCodetracePanel();
    }

    function createTableSpecial(_HT) {
        if (isPlaying) stop();
        htw.createTableSpecial(_HT);
        $('#progress-bar').slider("option", "max", 0);
        closeCreate();
        isPlaying = false;
        hideStatusPanel();
        hideCodetracePanel();
    }

    function insertInteger(callback) {
        if (isPlaying) stop();
        var input = $('#v-insert').val();
        commonAction(htw.getActiveStatus() == "SC" ? htw.insertSC(input, callback) : htw.insert(input, callback), "Insert " + input);
    }

    function searchInteger(callback) {
        if (isPlaying) stop();
        var input = parseInt($('#v-search').val());
        commonAction(htw.getActiveStatus() == "SC" ? htw.searchSC(input, callback) : htw.search(input, callback), "Search " + input);
    }

    function removeInteger(callback) {
        if (isPlaying) stop();
        var input = parseInt($('#v-remove').val());
        commonAction(htw.getActiveStatus() == "SC" ? htw.removeSC(input, callback) : htw.remove(input, callback), "Remove " + input);
    }

    function ENTER_LECTURE_MODE() {
    }
    function ENTER_EXPLORE_MODE() {

    }

    function CUSTOM_ACTION(action, data, mode) {
        if (action == 'create_special') {
            createTableSpecial(data);
        }
        else if (action == 'search') {
            hideSlide(function() {
                $('#v-search').val(data); // force
                searchInteger(showSlide);
            });
        }
        else if (action == 'insert') {
            hideSlide(function() {
                $('#v-insert').val(data); // force
                insertInteger(showSlide);
            });
        }
        else if (action == 'remove') {
            hideSlide(function() {
                $('#v-remove').val(data); // force
                removeInteger(showSlide);
            });
        }
    }
</script>
</body>
</html>
