<!DOCTYPE html>

<html>
<head>
    <meta charset="UTF-8">
    <title>链表(单向, 双向), 栈, 队列, 双端队列</title>
    <link rel="stylesheet" type="text/css" href="stylesheet.css">
    <link rel="stylesheet" type="text/css" href="common.css">
    <link rel="stylesheet" href="viz-1.0.1.css">
    <link rel="stylesheet" href="visual.css">
    <link rel="stylesheet" href="drawgraph.css">

    <style>
        .execAction { padding: 5px 8px; }
        .err { padding: 5px 0px; }
        #actions-extras input {
            width: 35px;
            padding: 5px 8px 7px;
        }

        .create { bottom: 146px; }
        .search { bottom: 119px; }
        .insert { bottom: 92px; }
        .remove { bottom: 65px; }

        #createfixedsize-input input, #createuserdefined-input input { float:left; }
        #createfixedsize-go p, #createuserdefined-go p { float:right; }
        #createuserdefined-input input { width: 80px; }

        #inserthead-input input, #inserttail-input input, #insertkth-input input { float: left; }
        #insertkth-input input { margin-right: 3px; }
        #inserthead-go p, #inserttail-go p, #insertkth-go p { float: right; }

        #removekth-input input {  float: left; }
        #removekth-go p { float: right; }
    </style>

</head>

<body>
<div id="top-bar">
    <span id="title">
    <a id='title-LL'  class='selected-viz' style="color:red">链表</a>
    <a id='title-Stack' style="color:red" >栈</a>
    <a id='title-Queue'  style="color:red">队列</a>
    <a id='title-DLL' style="color:red" >双向链表</a>
    <a id='title-Deque'  style="color:red">双端队列</a>
  </span>

    <div id="dark-overlay"></div>

    <div id="status" class="panel"><p></p></div>
    <div id="status-hide" class="panel-hide"><img src="arrow_white_right.png" alt=">" title="show/hide status panel"/></div>

    <div id="codetrace" class="panel">
        <p id="code1" style="padding-top: 10px;"></p>
        <p id="code2"></p>
        <p id="code3"></p>
        <p id="code4"></p>
        <p id="code5"></p>
        <p id="code6"></p>
        <p id="code7" style="padding-bottom: 10px;"></p>
    </div>
    <div id="codetrace-hide" class="panel-hide"><img src="arrow_white_right.png" alt=">" title="show/hide codetrace panel"/></div>

    <div id="left-bar"></div>
    <div id="right-bar"></div>

    <div id='viz'></div>
    <div id='current-action' class='panel'></div>
    <div id="overlay" hidden></div>
    <div id="dropdown-temp-holder" hidden></div>
    <div id="actions" class="panel">
        <p id="create">创建</p>
        <p id="search" class="execAction" onClick="searchGeneric()">找(v)</p>
        <p id="insert">插入(i,v)</p>
        <p id="remove" class="execAction" onClick="removeGeneric()">移除(i)</p>
    </div>
    <div id="actions-hide" class="panel-hide"><img src="arrow_white_right.png" alt=">" title="show/hide actions panel"/></div>

    <div id="actions-extras">
        <div class="create action-menu-pullout">
            <div id="create-empty" class="execAction new-menu-option coloured-menu-option" onClick="empty()"><p>空白</p></div>
            <div id="create-random" class="execAction new-menu-option coloured-menu-option" onClick="random()"><p>随机</p></div>
            <div id="create-random-sorted" class="execAction new-menu-option coloured-menu-option" onClick="randomSorted()"><p>Random Sorted</p></div>
            <div id="create-random-fixed-size" class="execAction new-menu-option coloured-menu-option" onclick="createModelingOpen('createfixedsize')"><p>Random Fixed Size</p>
                <div id="createfixedsize-input" class="new-menu-option">
                    <input type="number" id="v-create-size" title="Enter the size of the linked list" autocomplete="off" min=1 max=10 value=7>
                    <div id="createfixedsize-go" class="execAction coloured-menu-option" onClick="randomFixedSize()" title="Create random fixed size linked list"><p>执行</p></div>
                </div>
            </div>
            <div id="create-from-arr" class="execAction new-menu-option coloured-menu-option" onclick="createModelingOpen('createuserdefined')"><p>--- User Defined List ---</p>
                <div id="createuserdefined-input" class="new-menu-option">
                    <input type="text" id="v-create-arr" title="Enter the elements separated by comma" autocomplete="off" value="1,2,3">
                    <div id="createuserdefined-go" class="execAction coloured-menu-option" onClick="nonRandom()" title="Create random fixed size linked list"><p>执行</p></div>
                </div>
            </div>
            <div id="create-err" class="err"></div>
        </div>

        <div class="search action-menu-pullout">
            <div id="search-peek-front" style="display: none;" class="execAction new-menu-option coloured-menu-option" onclick="peekDeque('front')"><p>Front</p></div>
            <div id="search-peek-back" style="display: none;" class="execAction new-menu-option coloured-menu-option" onclick="peekDeque('back')"><p>Back</p></div>

            <div id="search-input" class="new-menu-option">v = <input type="number" id="v-search" title="Enter an Integer" autocomplete="off" min=0 max=99 value=5></div>
            <div id="search-go" class="execAction coloured-menu-option" onclick="searchVertex()"><p>执行</p></div>
            <div id="search-err" class="err"></div>
        </div>

        <div class="insert action-menu-pullout">

            <div id="pushtop-input" style="display: none;" class="new-menu-option">v = <input type="number" id="v-push-top-value" title="Enter an Integer" autocomplete="off" min=0 max=99 value=53></div>
            <div id="pushtop-go" style="display: none;" class="execAction coloured-menu-option" onclick="pushTop()"><p>执行</p></div>

            <div id="enqueueback-input" style="display: none;" class="new-menu-option">v = <input type="number" id="v-enqueue-back-value" title="Enter an Integer" autocomplete="off" min=0 max=99 value=57></div>
            <div id="enqueueback-go" style="display: none;" class="execAction coloured-menu-option" onclick="enqueueBack()"><p>执行</p></div>
            <div id="insert-deque-input" style="display: none;" class="new-menu-option">v = <input type="number" id="v-insert-deque-value" title="Enter an Integer" autocomplete="off" min=0 max=99 value=57></div>
            <div id="insert-deque-front" style="display: none;" class="execAction new-menu-option coloured-menu-option" onclick="insertDeque('front')"><p>Front</p></div>
            <div id="insert-deque-back" style="display: none;" class="execAction new-menu-option coloured-menu-option" onclick="insertDeque('back')"><p>Back</p></div>

            <div id="insert-head" class="execAction new-menu-option coloured-menu-option" onclick="insertModelingOpen('inserthead')"><p>i = 0 (Head), specify v =</p>
                <div id="inserthead-input" class="new-menu-option">
                    <input type="number" id="v-insert-head-value" title="Enter an Integer" autocomplete="off" min=0 max=99 value=85>
                    <div id="inserthead-go" class="execAction coloured-menu-option" onClick="insertHead()" title="Insert to Head"><p>执行</p></div>
                </div>
            </div>
            <div id="insert-tail" class="execAction new-menu-option coloured-menu-option" onclick="insertModelingOpen('inserttail')"><p>i = N (After Tail), specify v =</p>
                <div id="inserttail-input" class="new-menu-option">
                    <input type="number" id="v-insert-tail-value" title="Enter an Integer" autocomplete="off" min=0 max=99 value=80>
                    <div id="inserttail-go" class="execAction coloured-menu-option" onClick="insertTail()" title="Insert to Tail"><p>执行</p></div>
                </div>
            </div>
            <div id="insert-kth" class="execAction new-menu-option coloured-menu-option" onclick="insertModelingOpen('insertkth')"><p>specify both i in [1..N-1] and v =</p>
                <div id="insertkth-input" class="new-menu-option">
                    <input type="number" id="v-insert-kth" title="Enter an Integer" autocomplete="off" min=1 max=9 value=2>
                    <input type="number" id="v-insert-kth-value" title="Enter an Integer" autocomplete="off" min=0 max=99 value=90>
                    <div id="insertkth-go" class="execAction coloured-menu-option" onClick="insertKth()" title="Insert to kth"><p>执行</p></div>
                </div>
            </div>
            <div id="insert-err" class="err"></div>
        </div>

        <div class="remove action-menu-pullout">

            <div id="remove-deque-front" style="display:none;" class="execAction new-menu-option coloured-menu-option" onclick="removeDeque('front')"><p>Front</p></div>
            <div id="remove-deque-back" style="display:none;" class="execAction new-menu-option coloured-menu-option" onclick="removeDeque('back')"><p>Back</p></div>
            <!-- end -->
            <div id="remove-head" class="execAction new-menu-option coloured-menu-option" onClick="removeHead()"><p>Remove i = 0 (Head)</p></div>
            <div id="remove-tail" class="execAction new-menu-option coloured-menu-option" onClick="removeTail()"><p>Remove i = N-1 (Tail)</p></div>
            <div id="remove-kth" class="execAction new-menu-option coloured-menu-option" onclick="removeModelingOpen('removekth')"><p>specify i in [1..N-2]</p>
                <div id="removekth-input" class="new-menu-option">
                    <input type="number" id="v-remove-kth" title="Enter an Integer" autocomplete="off" min=1 max=8 value=2>
                    <div id="removekth-go" class="execAction coloured-menu-option" onClick="removeKth()" title="Remove k-th"><p>执行</p></div>
                </div>
            </div>
            <div id="remove-err" class="err"></div>
        </div>
    </div>

    <script src="jquery-3.1.1.min.js"></script>


    <script type="text/javascript">
        var PHP_DOMAIN = "";

        var colourArray = ["#52bc69", "#d65775"/*"#ed5a7d"*/, "#2ebbd1", "#d9513c", "#fec515", "#4b65ba", "#ff8a27", "#a7d41e"];

        function disableScroll() { $('html').css('overflow', 'hidden'); }

        function enableScroll() { $('html').css('overflow', 'visible'); }

        function replaceAll(find, replace, str) { return str.replace(new RegExp(find, 'g'), replace); }

        function getColours() {
            var generatedColours = new Array();
            while (generatedColours.length < 4) {
                var n = (Math.floor(Math.random() * colourArray.length));
                if ($.inArray(n, generatedColours) == -1)
                    generatedColours.push(n);
            }
            return generatedColours;
        }

        function isOn(value, position) {
            return (value>>position) & 1 === 1;
        }

        function customAlert(msg) {
            $('#custom-alert p').html(msg);
            var m = -1 * ($('#custom-alert').outerHeight()/2);
            $('#custom-alert').css('margin-top', m+'px');
            $('#dark-overlay').fadeIn(function() {
                $('#custom-alert').fadeIn(function() {
                    setTimeout(function() {
                        $('#custom-alert').fadeOut(function() {
                            $('#dark-overlay').fadeOut();
                        });
                    }, 1000);
                });
            });
        }

        function showLoadingScreen() {
            $('#loading-overlay').show();
            $('#loading-message').show();
        }

        function hideLoadingScreen() {
            $('#loading-overlay').hide();
        }

        function commonAction(retval, msg) {

            if (retval) {
                $('#current-action').show();
                $('#current-action').html(mode == "exploration" ? msg : ("e-Lecture Example (auto play until done)<br>" + msg));
                $('#progress-bar').slider("option", "max", gw.getTotalIteration()-1);
                triggerRightPanels();
                isPlaying = true;
            }

        }

        function getQueryVariable(variable) {
            var query = window.location.search.substring(1);
            var vars = query.split('&');
            for (var i = 0; i < vars.length; i++) {
                var pair = vars[i].split('=');
                if (decodeURIComponent(pair[0]) == variable)
                    return decodeURIComponent(pair[1]);
            }
            return "";
        }

        var generatedColours = getColours();
        var surpriseColour = colourArray[generatedColours[0]];
        var colourTheSecond = colourArray[generatedColours[1]];
        var colourTheThird = colourArray[generatedColours[2]];
        var colourTheFourth = colourArray[generatedColours[3]];

        $(function() {
            $('.links').css('background', surpriseColour);
            $('.right-links').css('background', surpriseColour);
            $('.colour').css("color", surpriseColour);
            $('h4').css("background-color", surpriseColour);


            $('#title a').click(function() {
                $('#title a').removeClass('selected-viz');
                $(this).addClass('selected-viz');

                setTimeout(function(){ document.body.style.zoom = "100.1%"; }, 100);
                setTimeout(function(){ document.body.style.zoom = "100%"; }, 600);
            });

            $('.close-overlay').click(function() {
                $('.overlays').fadeOut(function() {
                    $('#dark-overlay').fadeOut();
                });
            });

            $('#dark-overlay').click(function() {
                $('.overlays').fadeOut();
                $('#dark-overlay').fadeOut();
            });
        });

    </script>
    <script type="text/javascript" src="jquery-ui.min.js" ></script>
    <script type="text/javascript" src="d3.min.js"></script>
    <script type="text/javascript" src="viz-1.0.3.js"></script>
    <script type="text/javascript" src="graph_library-1.0.2.min.js"></script>

    <script>

            window.onpopstate = function(event) {
                var slide = event.state['slide'];
                openSlide(slide, function() {
                    runSlide(slide);
                });
            };

            function getUrlParameter(sParam) {
                var sPageURL = decodeURIComponent(window.location.search.substring(1)),
                    sURLVariables = sPageURL.split('&'), sParameterName, i;

                for (i = 0; i < sURLVariables.length; i++) {
                    sParameterName = sURLVariables[i].split('=');
                    if (sParameterName[0] === sParam) return sParameterName[1] === undefined ? true : sParameterName[1];
                }
            };

            function pushState(slideValue) {
                var url = '/zh/list';
                if (typeof slideValue != 'undefined' && slideValue != null) url += '?slide=' + slideValue;
                window.history.pushState({slide: slideValue}, "slide " + slideValue, url);
            }

            function showPopup(callback) {
                $('#popup').fadeIn(100, callback);
            }

            function hidePopup(callback) {
                $('#popup').fadeOut(100, callback);
            }

            function showOverlay() {
                $('#overlay').css('opacity', 0.5);
                $('#overlay').show();
            }

            function hideOverlay() {
                $('#overlay').hide();
                $("#e-lecture").html("");
            }

            function makeOverlayTransparent() {
                $('#overlay').css('opacity', 0);
            }

            function hideSlide(callback) {
                isPlaying = true;
                closeSlide(cur_slide, function() {
                    makeOverlayTransparent();
                    setTimeout(callback, 700);
                });
            }

            function showSlide() {
                isPlaying = false;
                openSlide(cur_slide);
                showOverlay();
            }

            $(function() {
                var slide = getUrlParameter('slide');

                $.get('/hasvisited' + '/list', function(data) {
                    var hasVisited = data['hasvisited'] == '1';
                    if (!hasVisited) {
                        var postData = {
                            '_token': '5FamGzI9Kj6yPBXGOrBdWVfgsweSR7H2Czx7ocIn',
                            'page': '/list'.substring(1),
                        };

                        $.post("/visitpage", postData, function(data) {

                        });

                        if (typeof slide != undefined && slide != null) {
                            cur_slide = slide;
                        }

                        $("#mode-menu a").trigger("click");
                    }
                    else {
                        if (typeof slide != undefined && slide != null) {
                            cur_slide = slide;
                            $('#mode-menu a').click();
                        }
                    }
                }).fail(function() {
                    if (typeof slide != undefined && slide != null) {
                        cur_slide = slide;
                        $('#mode-menu a').click();
                    }
                });

                $('.mcq-submit').click(function() {
                    var questionId = parseInt($(this).attr('id').split('-')[1]);
                    var answer = $('#mcq-answer-' + questionId).val();
                    var userAnswer = $('input[type=radio][name=mcq-'+questionId+'-choice]:checked').val();

                    if (answer === userAnswer) {
                        $('#answer-status-' + questionId).html('<font color="green"><b>Correct!</b></font>');
                    }
                    else {
                        $('#answer-status-' + questionId).html('<font color="red"><b>Wrong Answer! Try again...</b></font>');
                    }
                    $('#answer-status-' + questionId).show();
                    setTimeout(function() {
                        $('#answer-status-' + questionId).fadeOut(1000);
                    }, 1000);
                });

                $('.msq-submit').click(function() {
                    var questionId = parseInt($(this).attr('id').split('-')[1]);
                    var answer = $('#msq-answer-' + questionId).val();

                    var answers = [];
                    $('input[type=checkbox][class=msq-choice]:checked').each(function() {
                        answers.push($(this).attr('id').split('-')[3]);
                    });
                    answers.sort();
                    var userAnswer = answers.join(',');

                    if (answer === userAnswer) {
                        $('#answer-status-' + questionId).html('<font color="green">Correct!</font>');
                    }
                    else {
                        $('#answer-status-' + questionId).html('<font color="red">Wrong Answer! Try again...</font>');
                    }
                    $('#answer-status-' + questionId).show();
                    setTimeout(function() {
                        $('#answer-status-' + questionId).fadeOut(1000);
                    }, 1000);
                });

                $('select.lecture-dropdown').change(function() {
                    var nextSlide = $(this).val();
                    openSlide(nextSlide, function() {
                        runSlide(nextSlide);
                        pushState(nextSlide);
                    });
                });

                $('#hide-popup').click(function() {
                    hidePopup();
                });

                $('#popup').hover(function() {
                    $('#hide-popup').show();
                }, function() {
                    $('#hide-popup').hide();
                });



                setTimeout(function(){ document.body.style.zoom = "100.1%"; }, 500);
                setTimeout(function(){ document.body.style.zoom = "100%"; }, 600);
            });

            function doButtonAction96() {
                CUSTOM_ACTION('search','77');
            }
            function doButtonAction97() {
                CUSTOM_ACTION('search','7');
            }
            function doButtonAction98() {
                CUSTOM_ACTION('peek');
            }
            function doButtonAction99() {
                CUSTOM_ACTION('push','6');
            }
            function doButtonAction100() {
                $("#v-create-arr").val("22,2,77,6,43,76,89");
                nonRandom();
                CUSTOM_ACTION('insert_head','50');
            }
            function doButtonAction101() {
                $("#v-create-arr").val("22,2,77,6,43,76,89");
                nonRandom();
                CUSTOM_ACTION('insert_tail','10');
            }
            function doButtonAction102() {
                $("#v-create-arr").val("22,2,77,6,43,76,89");
                nonRandom();
                CUSTOM_ACTION('insert_kth','3,44');
            }
            function doButtonAction103() {
                empty();
                CUSTOM_ACTION('insert_head','50');
            }
            function doButtonAction104() {
                $("#v-create-arr").val("22,2,77,6,43,76,89");
                nonRandom();
                CUSTOM_ACTION('insert_kth','6,55');
            }
            function doButtonAction105() {
                CUSTOM_ACTION('remove_head');
            }
            function doButtonAction106() {
                CUSTOM_ACTION('remove_tail');
            }
            function doButtonAction107() {
                $("#v-create-arr").val("22,2,77,6,43,76,89");
                nonRandom();
                CUSTOM_ACTION('remove_kth','5');
            }
            function doButtonAction108() {
                CUSTOM_ACTION('enqueue');
            }

            function adjustPopupToImageSize() {
                var width = $('#popup-image').prop('width');
                var height = $('#popup-image').prop('height');
                $('#popup').width(width + 20);
                $('#popup').height(height + 20);
                if (width == 0 && height == 0) {
                    setTimeout(adjustPopupToImageSize, 200);
                } else {
                    showPopup();
                }
            }

            function POPUP_IMAGE(url) {
                $('#popup-content').html('<img id="popup-image" src="' + url + '">');
                adjustPopupToImageSize();
            }

            function URL(url) {
                window.open(url, '_blank');
            }
    </script>

    <script>
        function ENTER_LECTURE_MODE() {}


        function ENTER_EXPLORE_MODE() {}

        function CUSTOM_ACTION(action, data, mode) {}
    </script>

    <script type="text/javascript">


        var BACK_EDGE_CONST = 5000;

        var List = function() {
            var self = this;
            var graphWidget = new GraphWidget();
            var activeStatus = "list";
            var maxSize = 10;
            var maxStackSize = 7;

            var valueRange = [1, 99];
            var maxHeightAllowed = 10;

            var initialArray = [15, 6, 23, 4, 7, 71, 5, 50];
            var initialStackArray = [15, 6, 50, 4];



            var iL = {};
            var amountVertex = 0;
            var vertexClassNumberCounter = 9;
            iL["head"] = null;

            init(generateRandomArray(Math.floor((Math.random()*5 + 3))));

            this.setActiveStatus = function(newActiveStatus) {
                if (activeStatus != newActiveStatus) {
                    clearScreen();
                    activeStatus = newActiveStatus;
                    init(generateRandomArray(Math.floor((Math.random()*5 + 3))));
                }
            }

            this.getActiveStatus = function() { return activeStatus; }

            this.widgetRecalculatePosition = function() { recalculatePosition(); }

            this.getGraphWidget = function() { return graphWidget; }


            this.generate = function(initArr) { init(initArr); }

            function generateRandomArray(vertexAmt) {
                var initArr = new Array();
                while (initArr.length < vertexAmt) {
                    var random = Math.floor(1 + Math.random()*98);
                    if ($.inArray(random, initArr) < 0)
                        initArr.push(random);
                }
                return initArr;
            }

            this.generateRandom = function(isSorted) {
                var initArr = generateRandomArray(Math.floor((Math.random()*5 + 3))); // [3..7]
                if (isSorted) initArr.sort(function(a, b) { return a-b; }); // sort it first
                init(initArr);
                return true;
            };

            this.generateRandomFixedSize = function(val) {
                if (activeStatus == "stack") {
                    if (val > maxStackSize) {
                        $('#create-err').html('Sorry, the maximum number of vertex allowed is {maxSize}'.replace("{maxSize}", maxStackSize));
                        return false;
                    }
                }
                else {
                    if (val > maxSize) {
                        $('#create-err').html('Sorry, the maximum number of vertex allowed is {maxSize}'.replace("{maxSize}", maxSize));
                        return false;
                    }
                }
                var initArr = generateRandomArray(val);
                init(initArr);
                return true;
            }

            this.generateUserDefined = function(vertexTextArr) {
                var vertexAmt = vertexTextArr.length;
                if (activeStatus == "stack") {
                    if (vertexAmt > maxStackSize) {
                        $('#create-err').html('Sorry, the maximum number of vertex allowed is {maxSize}'.replace("{maxSize}", maxStackSize));
                        return false;
                    }
                }
                else {
                    if (vertexAmt > maxSize) {
                        $('#create-err').html('Sorry, the maximum number of vertex allowed is {maxSize}'.replace("{maxSize}", maxSize));
                        return false;
                    }
                }

                if (vertexTextArr == '') { // prevent creation of empty list
                    $('#create-err').html('Sorry, the minimum number of vertex is at least 1.');
                    return false;
                }

                var initArr = new Array();
                for (i = 0; i < vertexTextArr.length; i++) {
                    var vt = parseInt(vertexTextArr[i]);
                    if (!isNaN(vt) && $.inArray(vt, initArr) < 0) // remove duplicates
                        initArr.push(vt);
                }
                init(initArr);
                return true;
            }

            this.getA = function() {
                var theArr = [], currentVertex = iL["head"];
                while (currentVertex != null) {
                    theArr.push(currentVertex);
                    currentVertex = iL[currentVertex]["next"];
                }
                return theArr;
            }



            this.search = function(val, callback) {
                var stateList = [], vertexTraversed = {}, edgeTraversed = {}, currentVertex = iL["head"], cs = createState(iL), curVtxIdx, key, index = 0;

                if (currentVertex == null) {
                    cs = createState(iL, vertexTraversed, edgeTraversed);

                    cs["lineNo"] = 1;
                    stateList.push(cs);
                }
                else {

                    cs = createState(iL, vertexTraversed, edgeTraversed);
                    curVtxIdx = iL[currentVertex]["vtxIdx"];
                    cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
                    cs["vl"][curVtxIdx]["extratext"] = curVtxIdx + (curVtxIdx == 0 ? "/head" : (iL[currentVertex]["next"] == null ? "/tail" : "")) + "/temp";

                    cs["status"] = 'This is the current Linked List.<br>We want to search for value v = {val} starting from the head (index 0).'.replace("{val}", val);
                    cs["lineNo"] = 2;
                    stateList.push(cs);


                    while (parseInt(currentVertex) != parseInt(val)) {
                        vertexTraversed[currentVertex] = true;
                        cs = createState(iL, vertexTraversed, edgeTraversed);

                        cs["status"] = 'Comparing {currentVertex} (index = {index}) with v = {val}.<br>{currentVertex} is not equal to {val} so we have to continue.'.replace("{currentVertex}", currentVertex).replace("{val}", val).replace("{index}", index).replace("{currentVertex}", currentVertex).replace("{val}", val);
                        cs["vl"][curVtxIdx]["extratext"] = curVtxIdx + (curVtxIdx == 0 ? "/head" : (iL[currentVertex]["next"] == null ? "/tail" : "")) + "/temp";
                        cs["lineNo"] = 3;
                        stateList.push(cs);

                        currentVertex = iL[currentVertex]["next"];
                        if (currentVertex == null) {

                            cs = createState(iL, vertexTraversed, edgeTraversed);

                            cs["status"] = 'We try advancing temp to the next vertex.<br>But...';
                            cs["lineNo"] = 4;
                            stateList.push(cs);


                            cs = createState(iL, vertexTraversed, edgeTraversed);

                            cs["status"] = 'temp is null (we have gone past the tail after O(N) step(s)).<br>We conclude that value v = {val} is NOT_FOUND in the Linked List.'.replace("{val}", val);
                            cs["lineNo"] = [5, 6];
                            stateList.push(cs);

                            break;
                        }


                        curVtx = iL[currentVertex]["prev"];
                        curVtxIdx = iL[currentVertex]["vtxIdx"];
                        var edgeHighlighted = iL[curVtx]["vtxIdx"];
                        edgeTraversed[edgeHighlighted] = true;
                        if ((activeStatus == "doublylist") || (activeStatus == "deque"))
                            edgeTraversed[edgeHighlighted + BACK_EDGE_CONST] = true;
                        cs = createState(iL, vertexTraversed, edgeTraversed);
                        cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
                        cs["vl"][curVtxIdx]["extratext"] = curVtxIdx + (curVtxIdx == 0 ? "/head" : (iL[currentVertex]["next"] == null ? "/tail" : "")) + "/temp";
                        cs["el"][edgeHighlighted]["animateHighlighted"] = true;
                        cs["el"][edgeHighlighted]["state"] = EDGE_TRAVERSED;

                        cs["status"] = 'So temp advances to the next vertex.<br>temp is not null, continue searching.';
                        cs["lineNo"] = [4, 5];
                        stateList.push(cs);

                        index++;
                    }


                    if (currentVertex != null) {

                        cs = createState(iL, vertexTraversed, edgeTraversed);
                        curVtxIdx = iL[currentVertex]["vtxIdx"];
                        cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
                        cs["vl"][curVtxIdx]["extratext"] = curVtxIdx + (curVtxIdx == 0 ? "/head" : (iL[currentVertex]["next"] == null ? "/tail" : "")) + "/temp";

                        cs["status"] = 'Found value v = {val} at this highlighted vertex so we return index {index}.<br>The whole operation is O(N).'.replace("{val}", val).replace("{index}", index);
                        cs["lineNo"] = 7;
                        stateList.push(cs);
                    }
                }

                graphWidget.startAnimation(stateList, callback);
                populatePseudocode(4);
                return true;
            };

            this.peek = function(isHead, callback) {
                var stateList = [], vertexTraversed = {}, edgeTraversed = {}, currentVertex = iL["head"], cs = createState(iL), curVtxIdx, key, index = 0;

                if (currentVertex == null) {
                    cs = createState(iL, vertexTraversed, edgeTraversed);

                    cs["status"] = 'The current Linked List is empty, we return NOT_FOUND.';
                    cs["lineNo"] = 1;
                    stateList.push(cs);
                }
                else {
                    if (!isHead) {
                        while (true) { // go to tail
                            if (iL[currentVertex]["next"] != null) currentVertex = iL[currentVertex]["next"];
                            else break;
                        }
                    }

                    cs = createState(iL, vertexTraversed, edgeTraversed);
                    curVtxIdx = iL[currentVertex]["vtxIdx"];
                    cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;

                    cs["status"] = (isHead ? 'Return the value stored at the head: {currentVertex}.' : 'Return the value stored at the tail: {currentVertex}.').replace("{currentVertex}", currentVertex);
                    cs["lineNo"] = 2;
                    stateList.push(cs);
                }

                graphWidget.startAnimation(stateList, callback);
                populatePseudocode(isHead ? 3 : 9);
                return true;
            }


            this.insertHead = function(v, callback) {
                var val = parseInt(v);
                var tempinternalList = deepCopy(iL);


                if (isNaN(val)) {

                    $('#insert-err').html('Please fill in an Integer.');
                    return false;
                }

                if (tempinternalList[val] != null) {

                    $('#insert-err').html('No duplicate vertex allowed!');
                    if (typeof callback == 'function') callback();
                    return false;
                }

                if (parseInt(val) < valueRange[0] || parseInt(val) > valueRange[1]) {

                    $('#insert-err').html('Sorry, only values between {range0} and {range1} can be inserted.'.replace("{range0}", valueRange[0]).replace("{range1}", valueRange[1]));
                    return false;
                }

                if (activeStatus == "stack") {
                    if (amountVertex >= maxStackSize) {

                        $('#insert-err').html('Sorry, the maximum size is {maxSize}.'.replace("{maxSize}", maxStackSize));
                        return false;
                    }
                }
                else {
                    if (amountVertex >= maxSize) {

                        $('#insert-err').html('Sorry, the maximum size is {maxSize}.'.replace("{maxSize}", maxSize));
                        return false;
                    }
                }

                var stateList = [], vertexTraversed = {}, edgeTraversed = {}, currentVertex = iL["head"], cs = {}, curVtxIdx;
                if (amountVertex >= 1) cs = createState(iL);
                else                   cs = {};


                iL[parseInt(val)] = {
                    "next": null,
                    "vtxIdx": vertexClassNumberCounter++
                };


                var newVtx = parseInt(val);
                var oldHeadIdx;

                iL[newVtx]["cx"] = 50;
                iL[newVtx]["cy"] = 120;


                amountVertex++;
                if (amountVertex > 1) {
                    var tempChild = iL["head"];
                    oldHeadIdx = iL[tempChild]["vtxIdx"];
                    iL[newVtx]["next"] = tempChild;
                    iL[tempChild]["prev"] = newVtx;
                    iL["head"] = newVtx;
                }
                else
                    iL["head"] = newVtx;


                var newVtxIdx = iL[parseInt(val)]["vtxIdx"];

                if (amountVertex > 1) {

                    cs = createState(iL, vertexTraversed, edgeTraversed);
                    cs["vl"][newVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
                    cs["vl"][newVtxIdx]["extratext"] = "vtx";
                    cs["vl"][oldHeadIdx]["extratext"] = "head";
                    cs["el"][newVtxIdx]["state"] = OBJ_HIDDEN;
                    if ((activeStatus == "doublylist") || (activeStatus == "deque"))
                        cs["el"][newVtxIdx + BACK_EDGE_CONST]["state"] = OBJ_HIDDEN;

                    cs["status"] = 'Create new vertex to store value {val}.'.replace("{val}", val);
                    cs["lineNo"] = 1;
                    stateList.push(cs);

                    cs = createState(iL, vertexTraversed, edgeTraversed);
                    var edgeHighlighted = iL[newVtx]["vtxIdx"];
                    cs["el"][edgeHighlighted]["animateHighlighted"] = true;
                    cs["el"][edgeHighlighted]["state"] = EDGE_HIGHLIGHTED;
                    cs["vl"][newVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
                    cs["vl"][newVtxIdx]["extratext"] = "vtx";
                    cs["vl"][oldHeadIdx]["extratext"] = "head";
                    if ((activeStatus == "doublylist") || (activeStatus == "deque"))
                        cs["el"][newVtxIdx + BACK_EDGE_CONST]["state"] = OBJ_HIDDEN;

                    cs["status"] = 'Now, vtx.next points to the current head.';
                    cs["lineNo"] = 2;
                    stateList.push(cs);

                    if ((activeStatus == "doublylist") || (activeStatus == "deque")) {

                        cs = createState(iL, vertexTraversed, edgeTraversed);
                        cs["vl"][oldHeadIdx]["extratext"] = "head";
                        cs["vl"][newVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
                        cs["vl"][newVtxIdx]["extratext"] = "vtx";
                        cs["el"][newVtxIdx+BACK_EDGE_CONST]["state"] = EDGE_HIGHLIGHTED;
                        cs["el"][newVtxIdx+BACK_EDGE_CONST]["animateHighlighted"] = true;

                        cs["status"] = '(Old) head.prev points to vtx.';
                        cs["lineNo"] = 3;
                        stateList.push(cs);
                    }
                }
                else {

                    cs = createState(iL, vertexTraversed, edgeTraversed);
                    cs["vl"][newVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
                    cs["vl"][newVtxIdx]["extratext"] = "vtx";

                    cs["status"] = 'Create new vertex to store value {val}.'.replace("{val}", val) + '<br>But as head is currently null, temp.next remains null.';
                    cs["lineNo"] = [1, 2];
                    stateList.push(cs);
                }


                cs = createState(iL, vertexTraversed, edgeTraversed);
                cs["vl"][newVtxIdx]["state"] = VERTEX_GREEN_FILL;
                cs["vl"][newVtxIdx]["extratext"] = "head/vtx";

                cs["status"] = 'Now, head points to vtx.';
                if ((activeStatus == "doublylist") || (activeStatus == "deque"))
                    cs["lineNo"] = 4;
                else
                    cs["lineNo"] = 3;
                stateList.push(cs);

                if (amountVertex == 1) {

                    cs = createState(iL, vertexTraversed, edgeTraversed);
                    cs["vl"][newVtxIdx]["state"] = VERTEX_GREEN_FILL;
                    cs["vl"][newVtxIdx]["extratext"] = "head/tail/vtx";

                    cs["status"] = 'Tail points to head.';
                    cs["lineNo"] = 3;
                    stateList.push(cs);
                }

                recalculatePosition();
                cs = createState(iL, vertexTraversed, edgeTraversed);
                cs["vl"][newVtxIdx]["state"] = VERTEX_GREEN_FILL;
                cs["vl"][newVtxIdx]["extratext"] = "head" + (amountVertex == 1 ? "/tail" : "") + "/vtx";

                cs["status"] = 'Re-layout the Linked List for visualization.<br>The whole process is O({N}).'.replace("{N}", "1");
                cs["lineNo"] = 0;
                stateList.push(cs);

                graphWidget.startAnimation(stateList, callback);
                populatePseudocode(1);
                return true;
            }

            this.insertTail = function(v, callback) {
                if (amountVertex == 0) return this.insertHead(v, callback);

                var val = parseInt(v);
                var tempinternalList = deepCopy(iL);

                if (isNaN(val)) {

                    $('#insert-err').html('请输入一个整数.');
                    if (typeof callback == 'function') callback();
                    return false;
                }
                if (tempinternalList[val] != null) {

                    $('#insert-err').html('No duplicate vertex allowed!');
                    if (typeof callback == 'function') callback();
                    return false;
                }

                if (parseInt(val) < valueRange[0] || parseInt(val) > valueRange[1]) {

                    $('#insert-err').html('Sorry, only values between {range0} and {range1} can be inserted.'.replace("{range0}", valueRange[0]).replace("{range1}", valueRange[1]));
                    if (typeof callback == 'function') callback();
                    return false;
                }

                if (amountVertex >= maxSize) {

                    $('#insert-err').html('Sorry, the maximum size is {maxSize}.'.replace("{maxSize}", maxSize));
                    if (typeof callback == 'function') callback();
                    return false;
                }

                var stateList = [], vertexTraversed = {}, edgeTraversed = {}, currentVertex = iL["head"], cs = {}, curVtxIdx;


                while (currentVertex != val && currentVertex != null) {
                    var nextVertex;
                    nextVertex = iL[currentVertex]["next"];
                    if (nextVertex == null) break;
                    else                    currentVertex = nextVertex;
                }


                var newVtx = parseInt(val);
                var oldTailIdx = iL[currentVertex]["vtxIdx"];

                iL[parseInt(val)] = {
                    "next": null,
                    "vtxIdx": vertexClassNumberCounter++
                };

                if (currentVertex != null) {
                    iL[parseInt(val)]["prev"] = currentVertex;
                    iL[currentVertex]["next"] = parseInt(val);
                }
                else {
                    iL[parseInt(val)]["prev"] = null;
                    iL["head"] = parseInt(val);
                }

                amountVertex++;
                recalculatePosition();

                var newVtxIdx = iL[parseInt(val)]["vtxIdx"];
                curVtxIdx = iL[currentVertex]["vtxIdx"];

                cs = createState(iL, vertexTraversed, edgeTraversed);
                cs["vl"][newVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
                cs["vl"][newVtxIdx]["extratext"] = "vtx";
                cs["vl"][oldTailIdx]["extratext"] = "tail";
                cs["el"][curVtxIdx]["state"] = OBJ_HIDDEN;
                if ((activeStatus == "doublylist") || (activeStatus == "deque"))
                    cs["el"][curVtxIdx+BACK_EDGE_CONST]["state"] = OBJ_HIDDEN;

                cs["status"] = 'Create new vertex to store value {val}.'.replace("{val}", val);
                cs["lineNo"] = 1;
                stateList.push(cs);

                cs = createState(iL, vertexTraversed, edgeTraversed);
                cs["vl"][curVtxIdx]["state"] = VERTEX_GREEN_FILL;
                cs["vl"][newVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
                cs["vl"][newVtxIdx]["extratext"] = "vtx";
                cs["vl"][oldTailIdx]["extratext"] = "tail";
                cs["el"][curVtxIdx]["state"] = EDGE_TRAVERSED;
                cs["el"][curVtxIdx]["animateHighlighted"] = true;
                if ((activeStatus == "doublylist") || (activeStatus == "deque"))
                    cs["el"][curVtxIdx+BACK_EDGE_CONST]["state"] = OBJ_HIDDEN;

                cs["status"] = 'Now temp.next points to new vertex.';
                cs["lineNo"] = 2;
                stateList.push(cs);

                if ((activeStatus == "doublylist") || (activeStatus == "deque")) {
                    cs = createState(iL, vertexTraversed, edgeTraversed);
                    cs["vl"][curVtxIdx]["state"] = VERTEX_GREEN_FILL;
                    cs["vl"][curVtxIdx]["extratext"] = "tail";
                    cs["vl"][newVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
                    cs["vl"][newVtxIdx]["extratext"] = "vtx";
                    cs["el"][curVtxIdx+BACK_EDGE_CONST]["state"] = EDGE_HIGHLIGHTED;
                    cs["el"][curVtxIdx+BACK_EDGE_CONST]["animateHighlighted"] = true;

                    cs["status"] = 'Update prev pointer of the new vertex to point back to the (old) tail.';
                    cs["lineNo"] = 2;
                    stateList.push(cs);
                }


                cs = createState(iL, vertexTraversed, edgeTraversed);
                cs["vl"][newVtxIdx]["state"] = VERTEX_GREEN_FILL;
                cs["vl"][newVtxIdx]["extratext"] = "tail/vtx";

                cs["status"] = 'Now, tail points to the new vertex too.<br>The whole operation is O(1) if we maintain the tail pointer.';
                cs["lineNo"] = 3;
                stateList.push(cs);

                graphWidget.startAnimation(stateList, callback);
                populatePseudocode(2);
                return true;
            }

            this.insertKth = function(index, v, callback) {

                if (isNaN(index)) {

                    $('#insert-err').html('Please fill in an Integer.');
                    return false;
                }
                if ((index < 1) || (index > amountVertex)) {

                    $('#insert-err').html('Please enter a valid index between [1..{limit}].'.replace("{limit}", Math.max(1, amountVertex-1)));
                    return false;
                }
                if (index == 0)            return this.insertHead(v);
                if (index == amountVertex) return this.insertTail(v);

                var val = parseInt(v);
                var tempinternalList = deepCopy(iL);
                if (isNaN(val)) {
                    $('#insert-err').html('Please fill in an Integer.');
                    return false;
                }

                if (tempinternalList[val] != null) {

                    $('#insert-err').html('No duplicate vertex allowed!');
                    return false;
                }

                if (parseInt(val) < valueRange[0] || parseInt(val) > valueRange[1]) {
                    $('#insert-err').html('Sorry, only values between {range0} and {range1} can be inserted.'.replace("{range0}", valueRange[0]).replace("{range1}", valueRange[1]));
                    return false;
                }

                if (amountVertex >= maxSize) {

                    $('#insert-err').html('Sorry, the maximum size is {maxSize}.'.replace("{maxSize}", maxSize));
                    return false;
                }

                var stateList = [], vertexTraversed = {}, edgeTraversed = {}, currentVertex = iL["head"], cs = {};
                var temp1Idx, temp2Idx, newVtxIdx;

                cs = createState(iL, vertexTraversed, edgeTraversed);
                temp1Idx = iL[currentVertex]["vtxIdx"];
                cs["vl"][temp1Idx]["state"] = VERTEX_HIGHLIGHTED;
                cs["vl"][temp1Idx]["extratext"] = "0/head/pre";
                vertexTraversed[currentVertex] = true;
                cs["status"] = 'Set temp1 to head.';
                cs["lineNo"] = 1;
                stateList.push(cs);
                var i = 0;
                for (var k = 0; k < index-1; k++) {
                    cs = createState(iL, vertexTraversed, edgeTraversed);
                    temp1Idx = iL[currentVertex]["vtxIdx"];
                    cs["vl"][temp1Idx]["state"] = VERTEX_HIGHLIGHTED;
                    cs["vl"][temp1Idx]["extratext"] = i + (i == 0 ? "/head" : (iL[currentVertex]["next"] == null ? "/tail" : "")) + "/pre";
                    vertexTraversed[currentVertex] = true;
                    cs["status"] = 'Decrement k, index specified has not been reached.<br>k is now: {k}.'.replace("{k}", k);
                    cs["lineNo"] = 2;
                    stateList.push(cs);

                    var nextVertex;
                    nextVertex = iL[currentVertex]["next"];

                    if (nextVertex == null) break;
                    else                    currentVertex = nextVertex;
                    curVtx = iL[currentVertex]["prev"];
                    cs = createState(iL, vertexTraversed, edgeTraversed);
                    var edgeHighlighted = iL[curVtx]["vtxIdx"];
                    edgeTraversed[edgeHighlighted] = true;
                    cs["vl"][temp1Idx]["extratext"] = i + (i == 0 ? "/head" : (iL[currentVertex]["next"] == null ? "/tail" : "")) + "/pre";
                    cs["el"][edgeHighlighted]["animateHighlighted"] = true;
                    cs["el"][edgeHighlighted]["state"] = EDGE_TRAVERSED;
                    cs["status"] = 'We set prev to the next vertex.';
                    cs["lineNo"] = 3;
                    stateList.push(cs);

                    i++;
                }

                if (currentVertex != null) {
                    cs = createState(iL, vertexTraversed, edgeTraversed);
                    temp1Idx = iL[currentVertex]["vtxIdx"];
                    cs["vl"][temp1Idx]["state"] = VERTEX_HIGHLIGHTED;
                    cs["vl"][temp1Idx]["extratext"] = i + (i == 0 ? "/head" : (iL[currentVertex]["next"] == null ? "/tail" : "")) + "/pre";
                    vertexTraversed[currentVertex] = true;

                    cs["status"] = 'We have found the insertion point.<br>We continue the next insertion step.';
                    cs["lineNo"] = 2;
                    stateList.push(cs);
                }
                var temp2Vertex = iL[currentVertex]["next"];
                temp2Idx = iL[temp2Vertex]["vtxIdx"];
                cs = createState(iL, vertexTraversed, edgeTraversed);
                cs["vl"][temp1Idx]["state"] = VERTEX_HIGHLIGHTED;
                cs["vl"][temp1Idx]["extratext"] = i + (i == 0 ? "/head" : (iL[currentVertex]["next"] == null ? "/tail" : "")) + "/pre";
                cs["vl"][temp2Idx]["state"] = VERTEX_BLUE_FILL;
                cs["vl"][temp2Idx]["extratext"] = (i+1) + (i+1 == 0 ? "/head" : (iL[temp2Vertex]["next"] == null ? "/tail" : "")) + "/aft";
                cs["el"][temp1Idx]["state"] = EDGE_TRAVERSED;
                cs["el"][temp1Idx]["animateHighlighted"] = true;
                edgeTraversed[temp1Idx] = true;
                cs["status"] = 'The index before insertion point is found.<br>pre is before the insertion point and aft is the insertion point.';
                cs["lineNo"] = 4;
                stateList.push(cs);

                iL[parseInt(val)] = {
                    "next": null,
                    "vtxIdx": vertexClassNumberCounter++
                };
                amountVertex++;
                var newVtx = parseInt(val);
                newVtxIdx = iL[parseInt(val)]["vtxIdx"];
                var tempChild;

                iL[newVtx]["cx"] = iL[temp2Vertex]["cx"];
                iL[newVtx]["cy"] = iL[temp2Vertex]["cy"] + 70;
                cs = createState(iL, vertexTraversed, edgeTraversed);
                cs["vl"][temp1Idx]["state"] = VERTEX_HIGHLIGHTED;
                cs["vl"][temp1Idx]["extratext"] = i + (i == 0 ? "/head" : (iL[currentVertex]["next"] == null ? "/tail" : "")) + "/pre";
                cs["vl"][temp2Idx]["state"] = VERTEX_BLUE_FILL;
                cs["vl"][temp2Idx]["extratext"] = (i+1) + (i+1 == 0 ? "/head" : (iL[temp2Vertex]["next"] == null ? "/tail" : "")) + "/aft";
                cs["vl"][newVtxIdx]["state"] = VERTEX_GREEN_FILL;
                cs["vl"][newVtxIdx]["extratext"] = "vtx";
                cs["status"] = 'Create new vertex to store value {val}.'.replace("{val}", val);
                cs["lineNo"] = 5;
                stateList.push(cs);
                edgeTraversed[newVtxIdx] = true;

                iL[newVtx]["next"] = temp2Vertex;
                iL[temp2Vertex]["prev"] = newVtx;

                cs = createState(iL, vertexTraversed, edgeTraversed);
                cs["vl"][temp1Idx]["state"] = VERTEX_HIGHLIGHTED;
                cs["vl"][temp1Idx]["extratext"] = i + (i == 0 ? "/head" : (iL[currentVertex]["next"] == null ? "/tail" : "")) + "/pre";
                cs["vl"][temp2Idx]["state"] = VERTEX_BLUE_FILL;
                cs["vl"][temp2Idx]["extratext"] = (i+1) + (i+1 == 0 ? "/head" : (iL[temp2Vertex]["next"] == null ? "/tail" : "")) + "/aft";
                cs["vl"][newVtxIdx]["state"] = VERTEX_GREEN_FILL;
                cs["vl"][newVtxIdx]["extratext"] = "vtx";
                cs["el"][temp1Idx]["state"] = EDGE_TRAVERSED;
                cs["el"][newVtxIdx]["state"] = EDGE_GREEN;
                cs["el"][newVtxIdx]["animateHighlighted"] = true;
                if ((activeStatus == "doublylist") || (activeStatus == "deque"))
                    cs["el"][newVtxIdx+BACK_EDGE_CONST]["state"] = OBJ_HIDDEN;
                cs["status"] = 'vtx.next points to aft.';
                cs["lineNo"] = 6;
                stateList.push(cs);
                if ((activeStatus == "doublylist") || (activeStatus == "deque")) {
                    cs = createState(iL, vertexTraversed, edgeTraversed);
                    cs["vl"][temp1Idx]["state"] = VERTEX_HIGHLIGHTED;
                    cs["vl"][temp1Idx]["extratext"] = i + (i == 0 ? "/head" : (iL[currentVertex]["next"] == null ? "/tail" : "")) + "/pre";
                    cs["vl"][temp2Idx]["state"] = VERTEX_BLUE_FILL;
                    cs["vl"][temp2Idx]["extratext"] = (i+1) + (i+1 == 0 ? "/head" : (iL[temp2Vertex]["next"] == null ? "/tail" : "")) + "/aft";
                    cs["vl"][newVtxIdx]["state"] = VERTEX_GREEN_FILL;
                    cs["vl"][newVtxIdx]["extratext"] = "vtx";
                    cs["el"][temp1Idx]["state"] = EDGE_TRAVERSED;
                    cs["el"][newVtxIdx]["state"] = EDGE_GREEN;
                    cs["el"][newVtxIdx+BACK_EDGE_CONST]["state"] = EDGE_GREEN;
                    cs["el"][temp1Idx+BACK_EDGE_CONST]["state"] = OBJ_HIDDEN;
                    cs["status"] = 'aft.prev points to vtx.';
                    cs["lineNo"] = 6;
                    stateList.push(cs);
                }

                iL[currentVertex]["next"] = newVtx;
                iL[newVtx]["prev"] = currentVertex;
                cs = createState(iL, vertexTraversed, edgeTraversed);
                cs["vl"][temp1Idx]["state"] = VERTEX_HIGHLIGHTED;
                cs["vl"][temp1Idx]["extratext"] = i + (i == 0 ? "/head" : (iL[currentVertex]["next"] == null ? "/tail" : "")) + "/pre";
                cs["vl"][temp2Idx]["state"] = VERTEX_BLUE_FILL;
                cs["vl"][temp2Idx]["extratext"] = (i+2) + (i+1 == 0 ? "/head" : (iL[temp2Vertex]["next"] == null ? "/tail" : "")) + "/aft";
                cs["vl"][newVtxIdx]["state"] = VERTEX_GREEN_FILL;
                cs["vl"][newVtxIdx]["extratext"] = (i+1) + "/vtx";
                cs["el"][newVtxIdx]["state"] = EDGE_GREEN;
                cs["el"][temp1Idx]["state"] = EDGE_TRAVERSED;
                if ((activeStatus == "doublylist") || (activeStatus == "deque"))
                    cs["el"][temp1Idx+BACK_EDGE_CONST]["state"] = OBJ_HIDDEN;
                cs["status"] = 'pre.next points to vtx.';
                cs["lineNo"] = 7;
                stateList.push(cs);
                if ((activeStatus == "doublylist") || (activeStatus == "deque")) {
                    cs = createState(iL, vertexTraversed, edgeTraversed);
                    cs["vl"][temp1Idx]["state"] = VERTEX_HIGHLIGHTED;
                    cs["vl"][temp1Idx]["extratext"] = i + (i == 0 ? "/head" : (iL[currentVertex]["next"] == null ? "/tail" : "")) + "/pre";
                    cs["vl"][temp2Idx]["state"] = VERTEX_BLUE_FILL;
                    cs["vl"][temp2Idx]["extratext"] = (i+2) + (i+1 == 0 ? "/head" : (iL[temp2Vertex]["next"] == null ? "/tail" : "")) + "/aft";
                    cs["vl"][newVtxIdx]["state"] = VERTEX_GREEN_FILL;
                    cs["vl"][newVtxIdx]["extratext"] = temp2Idx + "/vtx";
                    cs["el"][temp1Idx]["state"] = EDGE_TRAVERSED;
                    cs["el"][temp1Idx+BACK_EDGE_CONST]["state"] = EDGE_TRAVERSED;
                    cs["status"] = 'vtx.prev points to pre.';
                    cs["lineNo"] = 7;
                    stateList.push(cs);
                }

                recalculatePosition();
                cs = createState(iL, {}, {});
                cs["vl"][newVtxIdx]["state"] = VERTEX_GREEN_FILL;
                cs["vl"][newVtxIdx]["extratext"] = (i+1) + "/vtx";
                cs["status"] = 'Re-layout the Linked List for visualization.<br>The whole process is O({N}).'.replace("{N}", "N");
                cs["lineNo"] = 0;
                stateList.push(cs);

                graphWidget.startAnimation(stateList, callback);
                populatePseudocode(0);
                return true;
            }

            this.removeHead = function(callback) {
                var stateList = [], vertexTraversed = {}, edgeTraversed = {}, currentVertex = iL["head"], cs = {}, curVtxIdx;

                if (currentVertex == null) {
                    cs = createState(iL, vertexTraversed, edgeTraversed);
                    cs["status"] = 'The Linked List is already empty.<br>No action is performed.';
                    cs["lineNo"] = 1;
                    stateList.push(cs);
                }
                else {
                    if (iL[currentVertex]["next"] == null) {

                        cs = createState(iL, vertexTraversed, edgeTraversed);
                        curVtxIdx = iL[currentVertex]["vtxIdx"];
                        cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
                        cs["status"] = 'The head is the only vertex in this List.';
                        cs["lineNo"] = 2;
                        stateList.push(cs);
                        cs = createState(iL, vertexTraversed, edgeTraversed);
                        curVtxIdx = iL[currentVertex]["vtxIdx"];
                        cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
                        cs["status"] = 'Head points to next (which is null).';
                        cs["lineNo"] = 3;
                        stateList.push(cs);

                        curVtxIdx = iL[currentVertex]["vtxIdx"];

                        iL["head"] = null;
                        delete iL[currentVertex];
                        delete vertexTraversed[currentVertex];
                        delete edgeTraversed[curVtxIdx];

                        cs = createState(iL, vertexTraversed, edgeTraversed);
                        cs["status"] = 'Remove head vertex.<br>We now have an empty List.';
                        cs["lineNo"] = 4;
                        stateList.push(cs);
                    }
                    else {
                        curVtxIdx = iL[currentVertex]["vtxIdx"];
                        cs = createState(iL, vertexTraversed, edgeTraversed);
                        cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
                        cs["vl"][curVtxIdx]["extratext"] = "head/temp";
                        cs["status"] = 'The head has a next vertex.';
                        cs["lineNo"] = 2;
                        stateList.push(cs);

                        var rightChildVertex = iL[currentVertex]["next"];
                        curVtxIdx = iL[currentVertex]["vtxIdx"];
                        nextVtxIdx = iL[rightChildVertex]["vtxIdx"];

                        cs = createState(iL, vertexTraversed, edgeTraversed);
                        cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
                        cs["vl"][curVtxIdx]["extratext"] = "temp";
                        cs["vl"][nextVtxIdx]["state"] = VERTEX_GREEN_FILL;
                        cs["vl"][nextVtxIdx]["extratext"] = "head";
                        cs["el"][curVtxIdx]["state"] = EDGE_GREEN;
                        cs["el"][curVtxIdx]["animateHighlighted"] = true;
                        cs["status"] = 'head points to the next vertex.';
                        cs["lineNo"] = 3;
                        stateList.push(cs);

                        iL["head"] = rightChildVertex;
                        iL[rightChildVertex]["prev"] = null;


                        delete iL[currentVertex];
                        delete vertexTraversed[currentVertex];
                        delete edgeTraversed[curVtxIdx];
                        cs = createState(iL, vertexTraversed, edgeTraversed);
                        cs["vl"][nextVtxIdx]["state"] = VERTEX_GREEN_FILL;
                        cs["status"] = 'Delete temp = (previous) head.';
                        cs["lineNo"] = 4;
                        stateList.push(cs);

                        if ((activeStatus == "doublylist") || (activeStatus == "deque")) {
                            cs = createState(iL, vertexTraversed, edgeTraversed);
                            cs["vl"][nextVtxIdx]["state"] = VERTEX_GREEN_FILL;
                            cs["status"] = 'Set head.prev to null for consistency purpose.';
                            cs["lineNo"] = 5;
                            stateList.push(cs);
                        }

                        amountVertex--;
                        recalculatePosition(); // this line triggers some D3.js errors although OK? find the root cause?
                        cs = createState(iL, vertexTraversed, edgeTraversed);
                        cs["vl"][nextVtxIdx]["state"] = VERTEX_GREEN_FILL;
                        if (amountVertex == 1) cs["vl"][nextVtxIdx]["extratext"] = "head/tail";
                        cs["status"] = 'Re-layout the Linked List for visualization.<br>The whole process is O({N}).'.replace("{N}", "1");
                        stateList.push(cs);
                    }
                }

                graphWidget.startAnimation(stateList, callback);
                populatePseudocode(5);
                return true;
            }

            this.removeTail = function(callback) {
                if (amountVertex == 1) return this.removeHead(callback); // special case

                var stateList = [], vertexTraversed = {}, edgeTraversed = {}, currentVertex = iL["head"], cs = {}, curVtxIdx;

                if (currentVertex == null) {
                    cs = createState(iL, vertexTraversed, edgeTraversed);
                    cs["status"] = 'The Linked List is already empty.<br>No action is performed.';
                    cs["lineNo"] = 1;
                    stateList.push(cs);
                }
                else {
                    var nextVertex = iL[currentVertex]["next"], nextVtxIdx;
                    cs = createState(iL, vertexTraversed, edgeTraversed);
                    curVtxIdx = iL[currentVertex]["vtxIdx"];
                    cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
                    cs["vl"][curVtxIdx]["extratext"] = "head/pre";
                    cs["status"] = 'Set up pre pointer.<br>pre will eventually point to the last vertex before tail.';
                    cs["lineNo"] = 2;
                    stateList.push(cs);
                    cs = createState(iL, vertexTraversed, edgeTraversed);
                    curVtxIdx = iL[currentVertex]["vtxIdx"];
                    cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
                    cs["vl"][curVtxIdx]["extratext"] = "head/pre";
                    nextVtxIdx = iL[nextVertex]["vtxIdx"];
                    cs["vl"][nextVtxIdx]["state"] = VERTEX_GREEN_FILL;
                    cs["vl"][nextVtxIdx]["extratext"] = (iL[nextVertex]["next"] == null ? "tail/" : "") + "temp";
                    cs["el"][curVtxIdx]["animateHighlighted"] = true;
                    cs["el"][curVtxIdx]["state"] = EDGE_TRAVERSED;
                    cs["status"] = 'Set up temp pointer.<br>temp will eventually point to the current tail.';
                    cs["lineNo"] = 3;
                    stateList.push(cs);
                    var i = 0;
                    while (true) {
                        cs = createState(iL, vertexTraversed, edgeTraversed);
                        curVtxIdx = iL[currentVertex]["vtxIdx"];
                        cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
                        cs["vl"][curVtxIdx]["extratext"] = (i == 0 ? "head/" : "") + "pre";
                        nextVtxIdx = iL[nextVertex]["vtxIdx"];
                        cs["vl"][nextVtxIdx]["state"] = VERTEX_GREEN_FILL;
                        cs["vl"][nextVtxIdx]["extratext"] = (iL[nextVertex]["next"] == null ? "tail/" : "") + "temp";
                        vertexTraversed[currentVertex] = true;
                        cs["status"] = 'Check if temp.next is null.';
                        cs["lineNo"] = 4;
                        stateList.push(cs);

                        if (iL[nextVertex]["next"] != null) {
                            nextVertex = iL[nextVertex]["next"];
                            currentVertex = iL[currentVertex]["next"];
                            i++;
                        }
                        else
                            break;
                        cs = createState(iL, vertexTraversed, edgeTraversed);
                        curVtxIdx = iL[currentVertex]["vtxIdx"];
                        cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
                        cs["vl"][curVtxIdx]["extratext"] = (i == 0 ? "head/" : "") + "pre";
                        nextVtxIdx = iL[nextVertex]["vtxIdx"];
                        cs["vl"][nextVtxIdx]["state"] = VERTEX_GREEN_FILL;
                        cs["vl"][nextVtxIdx]["extratext"] = (iL[nextVertex]["next"] == null ? "tail/" : "") + "temp";
                        vertexTraversed[currentVertex] = true;
                        curVtx = iL[currentVertex]["prev"];
                        var edgeHighlighted = iL[curVtx]["vtxIdx"];
                        cs["el"][edgeHighlighted]["animateHighlighted"] = true;
                        cs["el"][edgeHighlighted]["state"] = EDGE_TRAVERSED;
                        edgeTraversed[edgeHighlighted] = true;
                        var edgeHighlighted2 = iL[currentVertex]["vtxIdx"];
                        cs["el"][edgeHighlighted2]["animateHighlighted"] = true;
                        cs["el"][edgeHighlighted2]["state"] = EDGE_GREEN;

                        cs["status"] = 'It is not null.<br>So both pre and temp pointers advance to their next vertex.';
                        cs["lineNo"] = 5;
                        stateList.push(cs);
                    }
                    cs = createState(iL, vertexTraversed, edgeTraversed);
                    curVtxIdx = iL[currentVertex]["vtxIdx"];
                    nextVtxIdx = iL[nextVertex]["vtxIdx"];
                    cs["el"][curVtxIdx]["state"] = OBJ_HIDDEN;
                    cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
                    cs["vl"][curVtxIdx]["extratext"] = (i == 0 ? "head/" : "") + "pre";
                    nextVtxIdx = iL[nextVertex]["vtxIdx"];
                    cs["vl"][nextVtxIdx]["state"] = VERTEX_GREEN_FILL;
                    cs["vl"][nextVtxIdx]["extratext"] = "tail/temp";
                    vertexTraversed[currentVertex] = true;
                    cs["status"] = 'It is null.<br>So set the next of pre (the new tail) to null.';
                    cs["lineNo"] = 6;
                    stateList.push(cs);

                    var curVtx = iL[nextVertex]["prev"];
                    if (curVtx != null) iL[curVtx]["next"] = null;
                    else                iL["head"] = null;

                    delete iL[nextVertex];
                    delete vertexTraversed[nextVertex];
                    delete edgeTraversed[nextVtxIdx];

                    amountVertex--;

                    cs = createState(iL, vertexTraversed, edgeTraversed);
                    cs["vl"][curVtxIdx]["state"] = VERTEX_GREEN_FILL;
                    if (amountVertex == 1) cs["vl"][curVtxIdx]["extratext"] = "head/tail";
                    cs["status"] = 'Delete temp (the previous tail) then update the tail pointer to pre (the current tail). The whole process is O(N) just to find the pre pointer.';
                    cs["lineNo"] = 7;
                    stateList.push(cs);
                }

                graphWidget.startAnimation(stateList, callback);
                populatePseudocode(6);
                return true;
            }

            this.removeTailDLL = function(callback) {
                if (amountVertex == 1) return this.removeHead(callback);

                var stateList = [], vertexTraversed = {}, edgeTraversed = {}, currentVertex = iL["head"], cs = {};

                if (currentVertex == null) {
                    cs = createState(iL, vertexTraversed, edgeTraversed);
                    cs["status"] = 'The Linked List is already empty.<br>No action is performed.';
                    cs["lineNo"] = 1;
                    stateList.push(cs);
                }
                else {
                    var nextVertex = iL[currentVertex]["next"];
                    var curVtxIdx, nextVtxIdx;

                    while (true) {
                        if (iL[nextVertex]["next"] != null) {
                            nextVertex = iL[nextVertex]["next"];
                            currentVertex = iL[currentVertex]["next"];
                        }
                        else
                            break;
                    }

                    curVtxIdx = iL[currentVertex]["vtxIdx"];
                    nextVtxIdx = iL[nextVertex]["vtxIdx"];
                    cs = createState(iL, vertexTraversed, edgeTraversed);
                    cs["vl"][nextVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
                    cs["vl"][nextVtxIdx]["extratext"] = "tail/temp";
                    cs["status"] = 'Set temp to (old) tail.';
                    cs["lineNo"] = 2;
                    stateList.push(cs);
                    cs = createState(iL, vertexTraversed, edgeTraversed);
                    cs["vl"][nextVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
                    cs["vl"][nextVtxIdx]["extratext"] = "temp";
                    cs["el"][curVtxIdx + BACK_EDGE_CONST]["state"] = EDGE_HIGHLIGHTED;
                    cs["vl"][curVtxIdx]["state"] = VERTEX_GREEN_FILL;
                    cs["vl"][curVtxIdx]["extratext"] = "tail";
                    cs["status"] = 'Set tail to tail.prev';
                    cs["lineNo"] = 3;
                    stateList.push(cs);
                    cs = createState(iL, vertexTraversed, edgeTraversed);
                    cs["vl"][curVtxIdx]["state"] = VERTEX_GREEN_FILL;
                    cs["vl"][curVtxIdx]["extratext"] = "tail";
                    cs["vl"][nextVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
                    cs["vl"][nextVtxIdx]["extratext"] = "temp";
                    cs["el"][curVtxIdx]["state"] = OBJ_HIDDEN;
                    vertexTraversed[currentVertex] = true;
                    cs["status"] = 'Set the next of (new) tail to null.';
                    cs["lineNo"] = 4;
                    stateList.push(cs);

                    var curVtx = iL[nextVertex]["prev"];
                    if (curVtx != null) iL[curVtx]["next"] = null;
                    else                iL["head"] = null;

                    delete iL[nextVertex];
                    delete vertexTraversed[nextVertex];
                    delete edgeTraversed[nextVtxIdx];

                    amountVertex--;

                    cs = createState(iL, vertexTraversed, edgeTraversed);
                    cs["vl"][curVtxIdx]["state"] = VERTEX_GREEN_FILL;
                    if (amountVertex == 1) cs["vl"][curVtxIdx]["extratext"] = "head/tail";

                    cs["status"] = 'Delete temp.<br>The whole operations is just O(1) as we can access (old) tail.prev.';
                    cs["lineNo"] = 5;
                    stateList.push(cs);
                }

                graphWidget.startAnimation(stateList, callback);
                populatePseudocode(8);
                return true;
            }

            this.removeKth = function(v, callback) {
                var index = parseInt(v);

                if (isNaN(index)) {
                    $('#remove-err').html('Please fill in an Integer.');
                    return false;
                }
                if (amountVertex < 3) {
                    $('#remove-err').html('This operation only works for N bigger than 2.');
                    return false;
                }
                if ((index < 1) || (index >= amountVertex-1)) {

                    $('#remove-err').html('Please enter a valid index between [1..{limit}].'.replace("{limit}", Math.max(1, amountVertex-2)));
                    return false;
                }

                if (index == 0) return this.removeHead(); // not going to be executable
                if (index == amountVertex-1) {
                    if (this.getActiveStatus() == "doublylist") return this.removeTailDLL();
                    else                                        return this.removeTail();
                }

                var stateList = [], vertexTraversed = {}, edgeTraversed = {}, prevVtx = iL["head"], delVtx, afterVtx, cs = {};
                var prevIdx, delIdx, afterIdx;

                if (prevVtx == null) {
                    cs = createState(iL, vertexTraversed, edgeTraversed);

                    cs["status"] = 'The Linked List is already empty.<br>No action is performed.';
                    cs["lineNo"] = 1;
                    stateList.push(cs);
                }
                else {
                    prevIdx = iL[prevVtx]["vtxIdx"];
                    cs = createState(iL, vertexTraversed, edgeTraversed);
                    cs["vl"][prevIdx]["state"] = VERTEX_HIGHLIGHTED;
                    cs["vl"][prevIdx]["extratext"] = "0/head/pre";
                    cs["status"] = 'Set prev to head.<br>Pointer prev will stop at one vertex before the deleted vertex.';
                    cs["lineNo"] = 2;
                    stateList.push(cs);

                    for (i = 0; i < index-1; i++) {
                        cs = createState(iL, vertexTraversed, edgeTraversed);
                        cs["vl"][prevIdx]["state"] = VERTEX_HIGHLIGHTED;
                        cs["vl"][prevIdx]["extratext"] = i + (i == 0 ? "/head" : "") + "/pre";
                        vertexTraversed[prevVtx] = true;

                        cs["status"] = 'Index specified has not been reached.<br>k = {i}.'.replace("{k}", i);
                        cs["lineNo"] = 3;
                        stateList.push(cs);

                        var edgeHighlighted = iL[prevVtx]["vtxIdx"]; // before moving
                        prevVtx = iL[prevVtx]["next"];
                        prevIdx = iL[prevVtx]["vtxIdx"];

                        cs = createState(iL, vertexTraversed, edgeTraversed);
                        cs["vl"][prevIdx]["state"] = VERTEX_HIGHLIGHTED;
                        cs["vl"][prevIdx]["extratext"] = (i+1) + "/pre";
                        edgeTraversed[edgeHighlighted] = true;
                        cs["el"][edgeHighlighted]["animateHighlighted"] = true;
                        cs["el"][edgeHighlighted]["state"] = EDGE_TRAVERSED;
                        cs["status"] = 'Pointer prev advances to the next vertex.';
                        cs["lineNo"] = 4;
                        stateList.push(cs);
                    }

                    cs = createState(iL, vertexTraversed, edgeTraversed);
                    cs["vl"][prevIdx]["state"] = VERTEX_HIGHLIGHTED;
                    cs["vl"][prevIdx]["extratext"] = i + "/pre";
                    vertexTraversed[prevVtx] = true;

                    cs["status"] = 'k is 0, prev now points to one vertex behind the vertex to-be-deleted.<br>We stop searching and continue with the removal.';
                    cs["lineNo"] = 3;
                    stateList.push(cs);

                    var delVertex = iL[prevVtx]["next"];
                    delIdx = iL[delVertex]["vtxIdx"];
                    var afterVertex = iL[delVertex]["next"];
                    afterIdx = iL[afterVertex]["vtxIdx"];

                    cs = createState(iL, vertexTraversed, edgeTraversed);
                    cs["vl"][prevIdx]["state"] = VERTEX_HIGHLIGHTED;
                    cs["vl"][prevIdx]["extratext"] = i + "/pre";
                    cs["vl"][delIdx]["state"] = VERTEX_RED_FILL;
                    cs["vl"][delIdx]["extratext"] = (i+1) + "/del";
                    cs["vl"][afterIdx]["state"] = VERTEX_GREEN_FILL;
                    cs["vl"][afterIdx]["extratext"] = (i+2) + "/aft";
                    edgeTraversed[prevIdx] = edgeTraversed[delIdx] = true;
                    cs["el"][prevIdx]["animateHighlighted"] = cs["el"][delIdx]["animateHighlighted"] = true;
                    cs["el"][prevIdx]["state"] = EDGE_HIGHLIGHTED;
                    cs["el"][delIdx]["state"] = EDGE_RED;
                    if ((activeStatus == "doublylist") || (activeStatus == "deque")) {
                        cs["el"][prevIdx+BACK_EDGE_CONST]["state"] = EDGE_HIGHLIGHTED;
                        cs["el"][delIdx+BACK_EDGE_CONST]["state"] = EDGE_RED;
                    }
                    vertexTraversed[prevVtx] = true;
                    cs["status"] = 'We store reference to the vertex to-be-deleted.<br>We also store reference to the vertex after the to-be-deleted vertex.';
                    cs["lineNo"] = 5;
                    stateList.push(cs);

                    iL[delVertex]["cy"] = 50+iL[delVertex]["cy"];
                    iL[prevVtx]["next"] = afterVertex;
                    iL[afterVertex]["prev"] = prevVtx;

                    cs = createState(iL, vertexTraversed, edgeTraversed);
                    cs["vl"][prevIdx]["state"] = VERTEX_HIGHLIGHTED;
                    cs["vl"][prevIdx]["extratext"] = i + "/pre";
                    cs["vl"][delIdx]["state"] = VERTEX_RED_FILL;
                    cs["vl"][delIdx]["extratext"] = "del";
                    cs["vl"][afterIdx]["state"] = VERTEX_GREEN_FILL;
                    cs["vl"][afterIdx]["extratext"] = (i+1) + "/aft";
                    cs["el"][prevIdx]["animateHighlighted"] = true;
                    cs["el"][prevIdx]["state"] = EDGE_HIGHLIGHTED;
                    if ((activeStatus == "doublylist") || (activeStatus == "deque")) {
                        cs["el"][prevIdx+BACK_EDGE_CONST]["state"] = EDGE_HIGHLIGHTED;
                        cs["el"][delIdx+BACK_EDGE_CONST]["state"] = OBJ_HIDDEN;
                    }

                    cs["status"] = 'We connect the vertex behind the vertex to-be-deleted (pointer prev) with the next vertex after the vertex to-be-deleted (pointer after).';
                    cs["lineNo"] = 6;
                    stateList.push(cs);

                    delete iL[delVertex];
                    delete vertexTraversed[delVertex];
                    delete edgeTraversed[delIdx];
                    cs = createState(iL, vertexTraversed, edgeTraversed);
                    cs["vl"][prevIdx]["state"] = VERTEX_HIGHLIGHTED;
                    cs["vl"][afterIdx]["state"] = VERTEX_GREEN_FILL;
                    cs["status"] = 'Now we delete this vertex.';
                    cs["lineNo"] = 7;
                    stateList.push(cs);
                    amountVertex--;

                    recalculatePosition();
                    cs = createState(iL, {}, {});
                    cs["vl"][prevIdx]["state"] = VERTEX_HIGHLIGHTED;
                    cs["vl"][afterIdx]["state"] = VERTEX_GREEN_FILL;
                    if (amountVertex == 1) cs["vl"][afterIdx]["extratext"] = "head/tail";

                    cs["status"] = 'Re-layout the Linked List for visualization.<br>The whole process is O({N}).'.replace("{N}", "N");
                    stateList.push(cs);
                }

                graphWidget.startAnimation(stateList, callback);
                populatePseudocode(7);
                return true;
            }

            function init(initArr) {
                amountVertex = 0;
                clearScreen();

                for (var i = 0; i < initArr.length; i++) {
                    var curVtx = iL["head"];
                    var newVtx = parseInt(initArr[i]);

                    if (curVtx == null) {
                        iL["head"] = parseInt(newVtx);
                        iL[newVtx] = {
                            "prev": null,
                            "next": null,
                            "vtxIdx": amountVertex
                        };
                    }
                    else {
                        while (true) { // go to tail
                            if (iL[curVtx]["next"] == null) break;
                            curVtx = iL[curVtx]["next"];
                        }
                        iL[curVtx]["next"] = newVtx;
                        iL[newVtx] = {
                            "prev": curVtx,
                            "next": null,
                            "vtxIdx": amountVertex
                        }
                    }

                    amountVertex++;
                }

                recalculatePosition();

                for (key in iL) {
                    if (key == "head") continue;
                    graphWidget.addVertex(iL[key]["cx"], iL[key]["cy"], key, iL[key]["vtxIdx"], true, (iL["head"] == key ? "head" : (iL[key]["next"] == null ? "tail" : ""))); // iL[key]["vtxIdx"] +
                }

                for (key in iL) {
                    if (key == "head") continue;
                    if (key == iL["head"]) continue;
                    var curVtx = iL[key]["prev"];

                    graphWidget.addEdge(iL[curVtx]["vtxIdx"], iL[key]["vtxIdx"], iL[curVtx]["vtxIdx"], EDGE_TYPE_DE, 1, true);
                    if ((activeStatus == "doublylist") || (activeStatus == "deque"))
                        graphWidget.addEdge(iL[key]["vtxIdx"], iL[curVtx]["vtxIdx"], iL[curVtx]["vtxIdx"]+BACK_EDGE_CONST, EDGE_TYPE_DE, 1, true);
                }
            }

            function clearScreen() {
                var key;

                for (key in iL) {
                    if (key == "head") continue;
                    graphWidget.removeEdge(iL[key]["vtxIdx"] + BACK_EDGE_CONST);
                    graphWidget.removeEdge(iL[key]["vtxIdx"]);
                }

                for (key in iL) {
                    if (key == "head") continue;
                    graphWidget.removeVertex(iL[key]["vtxIdx"]);
                }

                iL = {};
                iL["head"] = null;
                amountVertex = 0;
            }

            this.getN = function() {
                return amountVertex;
            }



            function createState(iLObject, vertexTraversed, edgeTraversed) {
                if (vertexTraversed == null || vertexTraversed == undefined || !(vertexTraversed instanceof Object))
                    vertexTraversed = {};
                if (edgeTraversed == null || edgeTraversed == undefined || !(edgeTraversed instanceof Object))
                    edgeTraversed = {};

                var state = {
                    "vl": {},
                    "el": {}
                };
                var key;

                for (key in iLObject) {
                    if (key == "head") continue;

                    idx = iLObject[key]["vtxIdx"];

                    state["vl"][idx] = {};
                    state["vl"][idx]["cx"] = iLObject[key]["cx"];
                    state["vl"][idx]["cy"] = iLObject[key]["cy"];
                    state["vl"][idx]["text"] = key;
                    state["vl"][idx]["state"] = VERTEX_DEFAULT;

                    if (iLObject[key]["next"] == null) continue;

                    parentChildEdgeId = iLObject[key]["vtxIdx"];

                    state["el"][parentChildEdgeId] = {};

                    state["el"][parentChildEdgeId]["vertexA"] = iLObject[key]["vtxIdx"];
                    state["el"][parentChildEdgeId]["vertexB"] = iLObject[iLObject[key]["next"]]["vtxIdx"];
                    state["el"][parentChildEdgeId]["type"] = EDGE_TYPE_DE;
                    state["el"][parentChildEdgeId]["weight"] = 1;
                    state["el"][parentChildEdgeId]["state"] = EDGE_DEFAULT;
                    state["el"][parentChildEdgeId]["animateHighlighted"] = false;


                    if ((activeStatus == "doublylist") || (activeStatus == "deque")) {
                        parentChildEdgeId = iLObject[key]["vtxIdx"]+BACK_EDGE_CONST;
                        state["el"][parentChildEdgeId] = {};

                        state["el"][parentChildEdgeId]["vertexA"] = iLObject[iLObject[key]["next"]]["vtxIdx"];
                        state["el"][parentChildEdgeId]["vertexB"] = iLObject[key]["vtxIdx"];
                        state["el"][parentChildEdgeId]["type"] = EDGE_TYPE_DE;
                        state["el"][parentChildEdgeId]["weight"] = 1;
                        state["el"][parentChildEdgeId]["state"] = EDGE_DEFAULT;
                        state["el"][parentChildEdgeId]["animateHighlighted"] = false;
                    }
                }

                var cur = iLObject["head"], idx = 0;
                while (cur != null) {
                    curIdx = iLObject[cur]["vtxIdx"];
                    if (idx == 0)                      state["vl"][curIdx]["extratext"] = "head";
                    else if (iLObject[cur]["next"] == null) state["vl"][curIdx]["extratext"] = "tail";
                    cur = iLObject[cur]["next"];
                    idx++;
                }

                for (key in vertexTraversed) {
                    idx = iLObject[key]["vtxIdx"];
                    state["vl"][idx]["state"] = VERTEX_TRAVERSED;
                }

                for (key in edgeTraversed) {
                    state["el"][key]["state"] = EDGE_TRAVERSED;
                    if (state["el"][key+BACK_EDGE_CONST] != null) state["el"][key+BACK_EDGE_CONST] = EDGE_TRAVERSED;
                }

                return state;
            }

            function recalculatePosition() {
                updatePosition(iL["head"]);

                function updatePosition(currentVertex) {
                    if (currentVertex == null) return;

                    if (activeStatus == "stack") { // relayout vertical
                        if (currentVertex == iL["head"])
                            iL[currentVertex]["cy"] = 20;
                        else {
                            var curVtx = iL[currentVertex]["prev"]
                            iL[currentVertex]["cy"] = iL[curVtx]["cy"] + 70;
                        }
                        iL[currentVertex]["cx"] = 350;
                    }
                    else {
                        if (currentVertex == iL["head"])
                            iL[currentVertex]["cx"] = 50;
                        else {
                            var curVtx = iL[currentVertex]["prev"];
                            iL[currentVertex]["cx"] = iL[curVtx]["cx"] + 80;
                        }
                        iL[currentVertex]["cy"] = 50;
                    }

                    updatePosition(iL[currentVertex]["next"]);
                }
            }
            function populatePseudocode(act) {
                switch (act) {
                    case 4:
                        $('#code1').html('if empty, return NOT_FOUND');
                        $('#code2').html('index = 0, temp = head');
                        $('#code3').html('while (temp.item != v)');
                        $('#code4').html('&nbsp&nbsp' + 'index++, temp = temp.next');
                        $('#code5').html('&nbsp&nbspif temp == null');
                        $('#code6').html('&nbsp&nbsp&nbsp&nbspreturn NOT_FOUND');
                        $('#code7').html('return index');
                        break;
                    case 3: // peek
                        $('#code1').html('if empty, return NOT_FOUND');
                        $('#code2').html('return head.item');
                        $('#code3').html('');
                        $('#code4').html('');
                        $('#code5').html('');
                        $('#code6').html('');
                        $('#code7').html('');
                        break;

                    case 9: // peek back
                        $('#code1').html('if empty, return NOT_FOUND');
                        $('#code2').html('return tail.item');
                        $('#code3').html('');
                        $('#code4').html('');
                        $('#code5').html('');
                        $('#code6').html('');
                        $('#code7').html('');
                        break;

                    case 1: // insertHead
                        $('#code1').html('Vertex vtx = new Vertex(v)');
                        $('#code2').html('vtx.next = head');
                        if ((activeStatus == "doublylist") || (activeStatus == "deque")) {
                            $('#code3').html('if (head != null) head.prev = temp');
                            if (amountVertex == 1)
                                $('#code4').html('head = vtx, tail = head');
                            else
                                $('#code4').html('head = vtx');
                        }
                        else if (amountVertex == 1) {
                            $('#code3').html('head = vtx, tail = head');
                            $('#code4').html('');
                        }
                        else {
                            $('#code3').html('head = vtx');
                            $('#code4').html('');
                        }
                        $('#code5').html('');
                        $('#code6').html('');
                        $('#code7').html('');
                        break;
                    case 2: // insertTail
                        $('#code1').html('Vertex vtx = new Vertex(v)');
                        if ((activeStatus == "doublylist") || (activeStatus == "deque"))
                            $('#code2').html('tail.next = temp, temp.prev = tail');
                        else
                            $('#code2').html('tail.next = vtx');
                        $('#code3').html('tail = vtx');
                        $('#code4').html('');
                        $('#code5').html('');
                        $('#code6').html('');
                        $('#code7').html('');
                        break;
                    case 0: // Insert
                        $('#code1').html('Vertex pre = head');
                        $('#code2').html('for (k = 0; k < i-1; k++)');
                        $('#code3').html('&nbsp&nbsp' + 'pre = pre.next');
                        $('#code4').html('Vertex aft = pre.next');
                        $('#code5').html('Vertex vtx = new Vertex(v)');
                        if ((activeStatus == "doublylist") || (activeStatus == "deque")) {
                            $('#code6').html('vtx.next = aft, aft.prev = vtx');
                            $('#code7').html('pre.next = vtx, vtx.prev = pre');
                        }
                        else {
                            $('#code6').html('vtx.next = aft');
                            $('#code7').html('pre.next = vtx');
                        }
                        break;

                    case 5: // remove head
                        $('#code1').html('if empty, do nothing');
                        $('#code2').html('temp = head');
                        $('#code3').html('head = head.next');
                        $('#code4').html('delete temp');
                        if ((activeStatus == "doublylist") || (activeStatus == "deque"))
                            $('#code5').html('if (head != null) head.prev = null');
                        else
                            $('#code5').html('');
                        $('#code6').html('');
                        $('#code7').html('');
                        break;
                    case 6: // remove tail (SLL)
                        $('#code1').html('if empty, do nothing');
                        $('#code2').html('Vertex pre = head');
                        $('#code3').html('temp = head.next');
                        $('#code4').html('while (temp.next != null)');
                        $('#code5').html('&nbsp&nbsp' + 'pre = pre.next');
                        $('#code6').html('pre.next = null');
                        $('#code7').html('delete temp, tail = pre');
                        break;
                    case 7: // remove kth
                        $('#code1').html('if empty, do nothing');
                        $('#code2').html('Vertex pre = head');
                        $('#code3').html('for (k = 0; k < i-1; k++)');
                        $('#code4').html('&nbsp&nbsp' + 'pre = pre.next');
                        $('#code5').html('Vertex del = pre.next, aft = del.next');
                        if ((activeStatus == "doublylist") || (activeStatus == "deque"))
                            $('#code6').html('pre.next = aft, aft.prev = pre');
                        else
                            $('#code6').html('pre.next = aft // bypass del');
                        $('#code7').html('delete del');
                        break;
                    case 8: // remove tail (DLL, easier)
                        $('#code1').html('if empty, do nothing');
                        $('#code2').html('temp = tail');
                        $('#code3').html('tail = tail.prev');
                        $('#code4').html('tail.next = null');
                        $('#code5').html('delete temp');
                        $('#code6').html('');
                        $('#code7').html('');
                        break;
                }
            }
        }
        var actionsWidth = 150;
        var statusCodetraceWidth = 420;
        var isCreateOpen = false, isSearchOpen = false, isInsertOpen = false, isRemoveOpen = false;

        function openCreate() {
            $(".create").css("bottom","146px");
            $('#createfixedsize-input').hide();
            $('#createuserdefined-input').hide();
            if (!isCreateOpen) {
                $('.create').fadeIn('fast');
                isCreateOpen = true;
            }
        }
        function closeCreate() {
            if (isCreateOpen) {
                $('.create').fadeOut('fast');
                $('#create-err').html("");
                isCreateOpen = false;
            }
        }

        function openSearch() {
            if (!isSearchOpen) {
                $('.search').fadeIn('fast');
                isSearchOpen = true;
            }
        }

        function closeSearch() {
            if (isSearchOpen) {
                $('.search').fadeOut('fast');
                $('#search-err').html("");
                isSearchOpen = false;
            }
        }

        function openInsert() {
            $(".insert").css("bottom","92px");
            $('#insertkth-input').hide();
            $('#inserthead-input').hide();
            $('#inserttail-input').hide();
            if (!isInsertOpen) {
                $('.insert').fadeIn('fast');
                isInsertOpen = true;
            }
        }

        function closeInsert() {
            if(isInsertOpen) {
                $('.insert').fadeOut('fast');
                $('#insert-err').html("");
                isInsertOpen = false;
            }
        }

        function openRemove() {
            $(".remove").css("bottom","65px");
            $('#removekth-input').hide();
            if (!isRemoveOpen) {
                $('.remove').fadeIn('fast');
                isRemoveOpen = true;
            }
        }

        function closeRemove() {
            if (isRemoveOpen) {
                $('.remove').fadeOut('fast');
                $('#remove-err').html("");
                isRemoveOpen = false;
            }
        }

        function hideEntireActionsPanel() {
            closeCreate();
            closeSearch();
            closeInsert();
            closeRemove();
            hideActionsPanel();
        }


        function SOP() {
            if (isPlaying) stop();
            showActionsPanel();
            hideStatusPanel();
            hideCodetracePanel();
            $("#title-链表").text("链表");
            $("#title-双向链表").text("双向链表");
        }

        $('#title-LL').click(function() {
            SOP();
            displayList();
            changeTextList();
            lw.setActiveStatus("list");
            $("#title-链表").text('链表');
        });

        $('#title-Stack').click(function() {
            SOP();
            displayStack();
            changeTextStack();
            lw.setActiveStatus("stack");
        });

        $('#title-Queue').click(function() {
            SOP();
            displayQueue();
            changeTextQueue();
            lw.setActiveStatus("queue");
        });

        $('#title-DLL').click(function() {
            SOP();
            displayList();
            changeTextDoublyList();
            lw.setActiveStatus("doublylist");
            $("#title-双向链表").text('双向链表');
        });

        $('#title-Deque').click(function() {
            SOP();
            displayDeque();
            changeTextDeque();
            lw.setActiveStatus("deque");
        });

        var lw = new List(), gw;

        $(function() {
            $('#play').hide();
            gw = lw.getGraphWidget();
            var five_modes = ["LL", "Stack", "Queue", "DLL", "Deque"];
            $('#title-'+five_modes[Math.floor(Math.random()*5)]).click(); // randomly open one of the five default example every time

            var llMode = getQueryVariable("mode");
            if (llMode.length > 0) {
                $('#title-' + llMode).click();
            }
            var createLL = getQueryVariable("create");
            if (createLL.length > 0) {
                var newLL = createLL.split(",");
                lw.generate(newLL);
            }
            var operation = getQueryVariable("operation");
            var operationValue = getQueryVariable("operationValue");
            var operationMode = getQueryVariable("operationMode");
            if (operation.length > 0) {
                switch (operation) {
                    case "insert":
                        openInsert();
                        insertModelingOpen(operationMode);
                        $("#" + operationMode + "-input input").val(operationValue);
                }
            }

            $('#create').click(function() {
                closeSearch();
                closeInsert();
                closeRemove();
                openCreate();
            });

            $('#search').click(function() {
                closeCreate();
                closeInsert();
                closeRemove();
                openSearch();
            });

            $('#insert').click(function() {
                closeCreate();
                closeSearch();
                closeRemove();
                openInsert();
            });

            $('#remove').click(function() {
                closeCreate();
                closeSearch();
                closeInsert();
                openRemove();
            });
        });

        function allOff() {
            $("#search-input").css("display", "none");
            $("#search-go").css("display", "none");
            $("#search-peek-front").css("display", "none");
            $("#search-peek-back").css("display", "none");

            $("#insert-head").css("display", "none");
            $("#insert-tail").css("display", "none");
            $("#insert-kth").css("display", "none");
            $("#pushtop-input").css("display", "none");
            $("#pushtop-go").css("display", "none");
            $("#enqueueback-input").css("display", "none");
            $("#enqueueback-go").css("display", "none");
            $("#insert-deque-input").css("display", "none");
            $("#insert-deque-front").css("display", "none");
            $("#insert-deque-back").css("display", "none");

            $("#remove-head").css("display", "none");
            $("#remove-tail").css("display", "none");
            $("#remove-kth").css("display", "none");
            $("#remove-deque-front").css("display", "none");
            $("#remove-deque-back").css("display", "none");
        }

        function displayList() {
            allOff();

            $("#search-input").css("display", "");
            $("#search-go").css("display", "");

            $("#insert-head").css("display", "");
            $("#insert-tail").css("display", "");
            $("#insert-kth").css("display", "");

            $("#remove-head").css("display", "");
            $("#remove-tail").css("display", "");
            $("#remove-kth").css("display", "");
        }

        function displayStack() {
            allOff();

            $("#pushtop-input").css("display", "");
            $("#pushtop-go").css("display", "");
        }

        function displayQueue() {
            allOff();

            $("#enqueueback-input").css("display", "");
            $("#enqueueback-go").css("display", "");
        }

        function displayDeque() {
            allOff();

            $("#search-peek-front").css("display", "");
            $("#search-peek-back").css("display", "");

            $("#insert-deque-input").css("display", "");
            $("#insert-deque-front").css("display", "");
            $("#insert-deque-back").css("display", "");

            $("#remove-deque-front").css("display", "");
            $("#remove-deque-back").css("display", "");
        }

        function changeTextList() {
            $("#create").text('创建');
            $("#search").text('找');
            $("#insert").text('插入');
            $("#remove").text('移除');
        }

        function changeTextStack() {
            $("#create").text('创建');
            $("#search").text('Peek');
            $("#insert").text('Push');
            $("#remove").text('Pop');
        }

        function changeTextQueue() {
            $("#create").text('创建');
            $("#search").text('Peek');
            $("#insert").text('Enqueue');
            $("#remove").text('Dequeue');
        }

        function changeTextDoublyList() {
            $("#create").text('创建');
            $("#search").text('找');
            $("#insert").text('插入');
            $("#remove").text('移除');
        }

        function changeTextDeque() {
            $("#create").text('创建');
            $("#search").text('Peek');
            $("#insert").text('Enqueue');
            $("#remove").text('Dequeue');
        }

        function empty() {
            if (isPlaying) stop();
            if (lw.generateRandomFixedSize(0)) {
                $('#progress-bar').slider("option", "max", 0);
                closeCreate();
                isPlaying = false;
            }
            hideStatusPanel();
            hideCodetracePanel();
        }

        function random() {
            if (isPlaying) stop();
            if (lw.generateRandom(false)) {
                $('#progress-bar').slider("option", "max", 0);
                closeCreate();
                isPlaying = false;
            }
            hideStatusPanel();
            hideCodetracePanel();
        }

        function randomSorted() {
            if (isPlaying) stop();
            if (lw.generateRandom(true)) {
                $('#progress-bar').slider("option", "max", 0);
                closeCreate();
                isPlaying = false;
            }
            hideStatusPanel();
            hideCodetracePanel();
        }

        function randomFixedSize() {
            if (isPlaying) stop();
            var input = $('#v-create-size').val();
            input = parseInt(input);
            if (lw.generateRandomFixedSize(input)) {
                $('#progress-bar').slider("option", "max", 0);
                closeCreate();
                isPlaying = false;
            }
            hideStatusPanel();
            hideCodetracePanel();
        }

        function nonRandom() {
            if (isPlaying) stop();
            var input = $('#v-create-arr').val();
            input = input.split(",");
            if (lw.generateUserDefined(input)) {
                $('#progress-bar').slider("option", "max", 0);
                closeCreate();
                isPlaying = false;
            }
            hideStatusPanel();
            hideCodetracePanel();
        }

        function searchVertex(callback) {
            if (isPlaying) stop();
            var input = parseInt($('#v-search').val());
            commonAction(lw.search(input, callback), "找 " + input);
            setTimeout(function() {
                if (Math.random() > 0.5) // 50% chance totally random
                    $('#v-search').val(1 + Math.floor(Math.random()*99));
                else { // 50% something that is inside the list
                    var a = lw.getA();
                    $('#v-search').val(a[Math.floor(Math.random()*a.length)]);
                }
            }, 500);
        }

        function peekStack(callback) {
            if (isPlaying) stop();
            commonAction(lw.peek(true, callback), 'Peek top (head)');
        }

        function peekQueue(callback) {
            if (isPlaying) stop();
            commonAction(lw.peek(true, callback), 'Peek front (head)');
        }

        function searchGeneric(callback) {
            if (lw.getActiveStatus() == "stack")
                peekStack(callback);
            else if (lw.getActiveStatus() == "queue")
                peekQueue(callback);
        }

        function peekDeque(location, callback) {
            if (isPlaying) stop();
            if (location == "front")
                commonAction(lw.peek(true, callback), 'Peek front (head)');
            else
                commonAction(lw.peek(false, callback), 'Peek back (tail)');
        }

        function insertHead(callback) {
            if (isPlaying) stop();
            var input = parseInt($('#v-insert-head-value').val());
            commonAction(lw.insertHead(input, callback), 'Insert {input} at head'.replace("{input}", input));
            setTimeout(function() { $('#v-insert-head-value').val(1 + Math.floor(Math.random()*99)); }, 500);
        }

        function insertTail(callback) {
            if (isPlaying) stop();
            var input = parseInt($('#v-insert-tail-value').val());
            commonAction(lw.insertTail(input, callback), 'Insert {input} at tail'.replace("{input}", input));
            setTimeout(function() { $('#v-insert-tail-value').val(1 + Math.floor(Math.random()*99)); }, 500);
        }

        function insertKth(callback) {
            if (isPlaying) stop();
            var index = parseInt($('#v-insert-kth').val());
            var input = parseInt($('#v-insert-kth-value').val());
            commonAction(lw.insertKth(index, input, callback), 'Insert {input} at index {index}'.replace("{input}", input).replace("{index}", index));
            setTimeout(function() {
                $('#v-insert-kth').val(1 + Math.floor(Math.random()*(lw.getN()-1))); // [1..N-1]
                $('#v-insert-kth-value').val(1 + Math.floor(Math.random()*99));
            }, 500);
        }

        function pushTop(callback) {
            if (isPlaying) stop();
            var input = $('#v-push-top-value').val();
            commonAction(lw.insertHead(input, callback), 'Push {input} at top (head)'.replace("{input}", input));
            setTimeout(function() { $('#v-push-top-value').val(1 + Math.floor(Math.random()*99)); }, 500);
        }

        function enqueueBack(callback) {
            if (isPlaying) stop();
            var input = $('#v-enqueue-back-value').val();
            commonAction(lw.insertTail(input, callback), 'Enqueue {input} at back (tail)'.replace("{input}", input));
            setTimeout(function() { $('#v-enqueue-back-value').val(1 + Math.floor(Math.random()*99)); }, 500);
        }

        function insertDeque(location) {
            if (isPlaying) stop();
            var input = $('#v-insert-deque-value').val();
            if (location == "front")
                commonAction(lw.insertHead(input), 'Enqueue {input} to front (head)'.replace("{input}", input));
            else
                commonAction(lw.insertTail(input), 'Enqueue {input} to back (tail)'.replace("{input}", input));
            setTimeout(function() { $('#v-insert-deque-value').val(1 + Math.floor(Math.random()*99)); }, 500);
        }

        function removeHead(callback) { // PS both pop/stack and dequeue/queue also calls the same thing: remove head
            if (isPlaying) stop();
            commonAction(lw.removeHead(callback), 'Remove i = 0 (Head)');
        }

        function removeTail(callback) {
            if (isPlaying) stop();
            if (lw.getActiveStatus() == "doublylist" || lw.getActiveStatus() == "deque")
                commonAction(lw.removeTailDLL(callback), 'Remove i = N-1 (Tail)');
            else
                commonAction(lw.removeTail(callback), 'Remove i = N-1 (Tail)');
        }

        function removeKth(callback) {
            if (isPlaying) stop();
            var input = parseInt($('#v-remove-kth').val());
            commonAction(lw.removeKth(input, callback), 'Remove index {input}'.replace("{input}", input));
            setTimeout(function() { $('#v-remove-kth').val(1 + Math.floor(Math.random()*(lw.getN()-2))); }, 500); // [1..N-2]
        }

        function removeGeneric(callback) {
            if ((lw.getActiveStatus() == "stack") || (lw.getActiveStatus() == "queue"))
                removeHead(callback);
        }

        function removeDeque(location) {
            if (isPlaying) stop();
            if (location == "front")
                commonAction(lw.removeHead(), 'Remove front (head)');
            else
                commonAction(lw.removeTailDLL(), 'Remove back (tail)');
        }

        function createModelingOpen(modelingType) {
            $(".create").css("bottom", "119px");
            if (modelingType != "createfixedsize")
                $('#createfixedsize-input').fadeOut('fast');
            if (modelingType != "createuserdefined")
                $('#createuserdefined-input').fadeOut('fast');
            $('#'+modelingType+'-input').fadeIn('fast');
        }

        function insertModelingOpen(modelingType) {
            $(".insert").css("bottom", "65px");
            if (modelingType != "insertkth")
                $('#insertkth-input').fadeOut('fast');
            if (modelingType != "inserthead")
                $('#inserthead-input').fadeOut('fast');
            if (modelingType != "inserttail")
                $('#inserttail-input').fadeOut('fast');
            $('#'+modelingType+'-input').fadeIn('fast');
        }

        function removeModelingOpen(modelingType) {
            $(".remove").css("bottom", "38px");
            $('#'+modelingType+'-input').fadeIn('fast');
        }

        function ENTER_LECTURE_MODE() {

        }

        function ENTER_EXPLORE_MODE() {

        }

        function CUSTOM_ACTION(action, data, mode) {
            if (action == 'search') {
                hideSlide(function() {
                    $('#v-search').val(data);
                    searchVertex(showSlide);
                });
            }
            else if (action == 'peek') {
                hideSlide(function() {
                    searchGeneric(showSlide);
                });
            }
            else if (action == 'insert_head') {
                hideSlide(function() {
                    $('#v-insert-head-value').val(data);
                    insertHead(showSlide);
                });
            }
            else if (action == 'insert_tail') {
                hideSlide(function() {
                    $('#v-insert-tail-value').val(data);
                    insertTail(showSlide);
                });
            }
            else if (action == 'insert_kth') {
                hideSlide(function() {
                    $('#v-insert-kth').val(data.split(",")[0]);
                    $('#v-insert-kth-value').val(data.split(",")[1]);
                    insertKth(showSlide);
                });
            }
            else if (action == 'remove_head') {
                var a = lw.getA();
                if (a.length > 0) {
                    hideSlide(function() {
                        removeHead(showSlide);
                    });
                }
                else
                    alert('The Linked List is already empty');
            }
            else if (action == 'remove_tail') {
                var a = lw.getA();
                if (a.length > 0) {
                    hideSlide(function() {
                        removeTail(showSlide);
                    });
                }
                else
                    alert('The Linked List is already empty');
            }
            else if (action == 'remove_kth') {
                hideSlide(function() {
                    $('#v-remove-kth').val(data);
                    removeKth(showSlide);
                });
            }
            else if (action == 'push') {
                hideSlide(function() {
                    $('#v-push-top-value').val(data);
                    pushTop(showSlide);
                });
            }
            else if (action == 'enqueue') {
                var a = lw.getA();
                if (a.length < 10) {
                    var randval = 1 + Math.floor(Math.random()*99);
                    while (a.includes(randval))
                        randval = 1 + Math.floor(Math.random()*99);
                    hideSlide(function() {
                        $('#v-enqueue-back-value').val(randval); // force random
                        enqueueBack(showSlide);
                    });
                }
                else
                    alert('The Linked List is already too long for this visualization'); // put in variable?
            }
        }
    </script>
</div>
</body>
</html>
