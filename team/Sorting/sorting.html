<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">

    <meta property="og:image" content="https://visualgo.net/img/png/sorting.png">
    <title> 排序</title>

    <link rel="stylesheet" type="text/css" href="stylesheet.css">
    <link rel="stylesheet" type="text/css" href="common.css">
    <link rel="stylesheet" href="viz-1.0.1.css">
    <link rel="stylesheet" href="visual.css">
    <link rel="stylesheet" href="drawgraph.css">

    <style>
        .execAction { padding: 5px 8px; }
        .err { padding: 5px 0px; }
        #actions-extras input {
            width: 35px;
            padding: 5px 8px 7px;
        }

        .create { bottom: 92px; }
        .sort { bottom: 65px; }

        #create-sorted-increasing { float: left; }
        #create-sorted-decreasing { float: left;  }
        #create-nearly-sorted-increasing { float: left; }
        #create-nearly-sorted-decreasing { float: left; }
        #create-userdefined-input input { width: 300px; }

        text {
            fill: black;
            font: 20px sans-serif;
            text-anchor: middle;
        }

        #viz-radix-sort-canvas {
            position: fixed;
            top: 50%;
            left: 50%;
            margin-top: -250px;
            margin-left: -500px;
            height: 500px;
            width: 1000px;
        }

        div .radix-sort-element {
            position: absolute;
            border: 1px solid black;
            width: 55px;
            font: 20px sans-serif;
            color: black;
        }

        #radix-sort-bucket-labels-collection {
            position: absolute;
            bottom: 0px;
            left: 0px;
        }

        .radix-sort-bucket-label {
            position: absolute;
            border-top: 1px solid black;
            width: 57px;
            font: 20px sans-serif;
            color: black;
        }
        #sort-viz {
            width: 100%;
            text-align: center;
            overflow: hidden;
            padding-top: 10px;
        }
    </style>
</head>

<body>
<div id="top-bar">&nbsp;&nbsp;
    <span id="title">
    <a id='title-Bubble'  class='selected-viz'>冒泡</a>
    <a id='title-Selection' >选择</a>
    <a id='title-Insertion' >插入</a>
    <a id='title-Merge' >归并</a>
    <a id='title-Quick' >快速</a>
    <a id='title-RandomizedQuick' >随机快速</a>
    <a id='title-Counting' >计数</a>
    <a id='title-Radix' >基数</a>
  </span>

    <div id="dark-overlay"></div>

    <div id="status" class="panel"><p></p></div>
    <div id="status-hide" class="panel-hide"><img src="https://visualgo.net/img/arrow_white_right.png" alt=">" title="show/hide status panel"/></div>

    <div id="codetrace" class="panel">
        <p id="code1" style="padding-top: 10px;"></p>
        <p id="code2"></p>
        <p id="code3"></p>
        <p id="code4"></p>
        <p id="code5"></p>
        <p id="code6"></p>
        <p id="code7" style="padding-bottom: 10px;"></p>
    </div>
    <div id="codetrace-hide" class="panel-hide"><img src="https://visualgo.net/img/arrow_white_right.png" alt=">" title="show/hide codetrace panel"/></div>

    <div id="left-bar"></div>
    <div id="right-bar"></div>


    <!--快慢代码-->
    <div id="overlay" hidden></div>
    <div id="dropdown-temp-holder" hidden></div>

    <div id="sort-viz">
        <svg id="viz-canvas"></svg><br>
        <svg id="viz-counting-sort-secondary-canvas"></svg>
        <div id="viz-radix-sort-canvas">
    <span id="radix-sort-bucket-labels-collection">
      <span class="radix-sort-bucket-label">0</span>
      <span class="radix-sort-bucket-label">1</span>
      <span class="radix-sort-bucket-label">2</span>
      <span class="radix-sort-bucket-label">3</span>
      <span class="radix-sort-bucket-label">4</span>
      <span class="radix-sort-bucket-label">5</span>
      <span class="radix-sort-bucket-label">6</span>
      <span class="radix-sort-bucket-label">7</span>
      <span class="radix-sort-bucket-label">8</span>
      <span class="radix-sort-bucket-label">9</span>
    </span>
        </div>
    </div>
    <div id="current-action" class="panel"><p></p></div>
    <div id="actions" class="panel">
        <p id="create">创建</p>
        <p id="sort">排序</p>
    </div>
    <div id="actions-hide" class="panel-hide"><img src="arrow_white_right.png" alt=">" title="show/hide actions panel"/></div>
    <div id="actions-extras">
        <div class="create action-menu-pullout">
            <div id="create-random" class="execAction new-menu-option coloured-menu-option" onclick="createList('random')"><p>随机</p></div>
            <div id="create-sorted" class="execAction new-menu-option coloured-menu-option" onclick="triggerSubmenu('sorted')">
                <p>已完成排序的</p>
                <div id="create-sorted-increasing" class="execAction coloured-menu-option" onclick="createList('sorted-increasing')"><p>升序</p></div>
                <div id="create-sorted-decreasing" class="execAction new-menu-option coloured-menu-option" onclick="createList('sorted-decreasing')"><p>降序</p></div>
            </div>
            <div id="create-nearly-sorted" class="execAction new-menu-option coloured-menu-option" onclick="triggerSubmenu('nearly-sorted')">
                <p>接近完成排序的</p>
                <div id="create-nearly-sorted-increasing" class="execAction coloured-menu-option" onclick="createList('nearly-sorted-increasing')"><p>升序</p></div>
                <div id="create-nearly-sorted-decreasing" class="execAction new-menu-option coloured-menu-option" onclick="createList('nearly-sorted-decreasing')"><p>降序</p></div>
            </div>
            <div id="create-userdefined-input" class="new-menu-option"><input type="text" id="userdefined-input" title="Enter a list of numbers, separated by commas." autocomplete="off" value="3,44,38,5,47,15,36,26,27,2,46,4,19,50,48"></div>
            <div id="create-userdefined-go" class="execAction new-menu-option coloured-menu-option" onclick="createList('userdefined')"><p>执行</p></div>
            <div id="create-err" class="err"></div>
        </div>
        <div class="sort action-menu-pullout">
            <div id="sort-bubble-merge-inversion" class="execAction new-menu-option coloured-menu-option"><input type="checkbox" id="sort-bubble-merge-inversion-checkbox">计算倒置指数</div>
            <div id="sort-go" class="execAction new-menu-option coloured-menu-option" onclick="sort()"><p>执行</p></div>
            <div id="sort-err" class="err"></div>
        </div>
    </div>

    <div id="bottom-bar">
        <a id="trigger-about"></a>

    </div>
    <script src="jquery-3.1.1.min.js"></script>
    <script type="text/javascript">
        var PHP_DOMAIN = "";


        var colourArray = ["#52bc69", "#d65775"/*"#ed5a7d"*/, "#2ebbd1", "#d9513c", "#fec515", "#4b65ba", "#ff8a27", "#a7d41e"]; // green, pink, blue, red, yellow, indigo, orange, lime

        function disableScroll() { $('html').css('overflow', 'hidden'); }

        function enableScroll() { $('html').css('overflow', 'visible'); }

        function replaceAll(find, replace, str) { return str.replace(new RegExp(find, 'g'), replace); }

        function getColours() {
            var generatedColours = new Array();
            while (generatedColours.length < 4) {
                var n = (Math.floor(Math.random() * colourArray.length));
                if ($.inArray(n, generatedColours) == -1)
                    generatedColours.push(n);
            }
            return generatedColours;
        }

        function isOn(value, position) {
            return (value>>position) & 1 === 1;
        }

        function customAlert(msg) {
            $('#custom-alert p').html(msg);
            var m = -1 * ($('#custom-alert').outerHeight()/2);
            $('#custom-alert').css('margin-top', m+'px');
            $('#dark-overlay').fadeIn(function() {
                $('#custom-alert').fadeIn(function() {
                    setTimeout(function() {
                        $('#custom-alert').fadeOut(function() {
                            $('#dark-overlay').fadeOut();
                        });
                    }, 1000);
                });
            });
        }

        function showLoadingScreen() {
            $('#loading-overlay').show();
            $('#loading-message').show();
        }

        function hideLoadingScreen() {
            $('#loading-overlay').hide();
        }

        function commonAction(retval, msg) {

            if (retval) {
                $('#current-action').show();
                $('#current-action').html(mode == "exploration" ? msg : ("e-Lecture Example (auto play until done)<br>" + msg));
                $('#progress-bar').slider("option", "max", gw.getTotalIteration()-1);
                triggerRightPanels();
                isPlaying = true;
            }

        }

        function getQueryVariable(variable) {
            var query = window.location.search.substring(1);
            var vars = query.split('&');
            for (var i = 0; i < vars.length; i++) {
                var pair = vars[i].split('=');
                if (decodeURIComponent(pair[0]) == variable)
                    return decodeURIComponent(pair[1]);
            }
            return "";
        }

        var generatedColours = getColours();
        var surpriseColour = colourArray[generatedColours[0]];
        var colourTheSecond = colourArray[generatedColours[1]];
        var colourTheThird = colourArray[generatedColours[2]];
        var colourTheFourth = colourArray[generatedColours[3]];

        $(function() {
            $('.links').css('background', surpriseColour);
            $('.right-links').css('background', surpriseColour);
            $('.colour').css("color", surpriseColour);
            $('h4').css("background-color", surpriseColour);
        });
    </script>
    <script type="text/javascript" src="jquery-ui.min.js"></script>
    <script type="text/javascript" src="d3.min.js"></script>
    <script type="text/javascript" src="viz-1.0.3.js"></script>
    <script type="text/javascript" src="graph_library-1.0.2.min.js"></script>

    <script>
        window.onpopstate = function(event) {
            var slide = event.state['slide'];
            openSlide(slide, function() {
                runSlide(slide);
            });
        };

        function getUrlParameter(sParam) {
            var sPageURL = decodeURIComponent(window.location.search.substring(1)),
                sURLVariables = sPageURL.split('&'), sParameterName, i;

            for (i = 0; i < sURLVariables.length; i++) {
                sParameterName = sURLVariables[i].split('=');
                if (sParameterName[0] === sParam) return sParameterName[1] === undefined ? true : sParameterName[1];
            }
        };

        function pushState(slideValue) {
            var url = '/zh/sorting';
            if (typeof slideValue != 'undefined' && slideValue != null) url += '?slide=' + slideValue;
            window.history.pushState({slide: slideValue}, "slide " + slideValue, url);
        }

        function showPopup(callback) {
            $('#popup').fadeIn(100, callback);
        }

        function hidePopup(callback) {
            $('#popup').fadeOut(100, callback);
        }

        function showOverlay() {
            $('#overlay').css('opacity', 0.5);
            $('#overlay').show();
        }

        function hideOverlay() {
            $('#overlay').hide();
            $("#e-lecture").html("");
        }

        function makeOverlayTransparent() {
            $('#overlay').css('opacity', 0);
        }

        function hideSlide(callback) {
            isPlaying = true;
            closeSlide(cur_slide, function() {
                makeOverlayTransparent();
                setTimeout(callback, 700);
            });
        }

        function showSlide() {
            isPlaying = false;
            openSlide(cur_slide);
            showOverlay();
        }

        $(function() {
            var slide = getUrlParameter('slide');

            $.get('/hasvisited' + '/sorting', function(data) {
                var hasVisited = data['hasvisited'] == '1';
                if (!hasVisited) {
                    var postData = {
                        '_token': 'MGKzg2iuBojiJihK73jAXrITR3ET4CDCmR0KQ4xK',
                        'page': '/sorting'.substring(1),
                    };

                    $.post("/visitpage", postData, function(data) {
                        // non critical request...
                    });

                    if (typeof slide != undefined && slide != null) {
                        cur_slide = slide;
                    }

                    $("#mode-menu a").trigger("click");
                }
                else {
                    if (typeof slide != undefined && slide != null) {
                        cur_slide = slide;
                        $('#mode-menu a').click();
                    }
                }
            }).fail(function() {
                if (typeof slide != undefined && slide != null) {
                    cur_slide = slide;
                    $('#mode-menu a').click();
                }
            });

            $('.mcq-submit').click(function() {
                var questionId = parseInt($(this).attr('id').split('-')[1]);
                var answer = $('#mcq-answer-' + questionId).val();
                var userAnswer = $('input[type=radio][name=mcq-'+questionId+'-choice]:checked').val();

                if (answer === userAnswer) {
                    $('#answer-status-' + questionId).html('<font color="green"><b>Correct!</b></font>');
                }
                else {
                    $('#answer-status-' + questionId).html('<font color="red"><b>Wrong Answer! Try again...</b></font>');
                }
                $('#answer-status-' + questionId).show();
                setTimeout(function() {
                    $('#answer-status-' + questionId).fadeOut(1000);
                }, 1000);
            });

            $('.msq-submit').click(function() {
                var questionId = parseInt($(this).attr('id').split('-')[1]);
                var answer = $('#msq-answer-' + questionId).val();

                var answers = [];
                $('input[type=checkbox][class=msq-choice]:checked').each(function() {
                    answers.push($(this).attr('id').split('-')[3]);
                });
                answers.sort();
                var userAnswer = answers.join(',');

                if (answer === userAnswer) {
                    $('#answer-status-' + questionId).html('<font color="green">Correct!</font>');
                }
                else {
                    $('#answer-status-' + questionId).html('<font color="red">Wrong Answer! Try again...</font>');
                }
                $('#answer-status-' + questionId).show();
                setTimeout(function() {
                    $('#answer-status-' + questionId).fadeOut(1000);
                }, 1000);
            });

            $('select.lecture-dropdown').change(function() {
                var nextSlide = $(this).val();
                openSlide(nextSlide, function() {
                    runSlide(nextSlide);
                    pushState(nextSlide);
                });
            });

            $('#hide-popup').click(function() {
                hidePopup();
            });

            $('#popup').hover(function() {
                $('#hide-popup').show();
            }, function() {
                $('#hide-popup').hide();
            });

            setTimeout(function(){ document.body.style.zoom = "100.1%"; }, 500);
            setTimeout(function(){ document.body.style.zoom = "100%"; }, 600);
        });

        function doButtonAction7() {
            POPUP_IMAGE('https://open.kattis.com/images/site-logo');
        }
        function doButtonAction8() {
            SORT();
        }
        function doButtonAction10() {
            SORT();
        }
        function doButtonAction11() {
            SORT();
        }
        function doButtonAction12() {
            SORT();
        }
        function doButtonAction13() {
            SORT();
        }
        function doButtonAction14() {
            SORT();
        }
        function doButtonAction15() {
            SORT();
        }
        function doButtonAction16() {
            SORT();
        }
        function doButtonAction17() {
            URL('../training?diff=Hard&n=10&tl=5&module=sorting');
        }
        function doButtonAction18() {
            POPUP_IMAGE('https://pbs.twimg.com/profile_images/2618373647/image.jpg');
        }
        function doButtonAction19() {
            URL('../login');
        }
        function doButtonAction20() {
            POPUP_IMAGE('https://puu.sh/vfi6a/e532309371.png');
        }
        function doButtonAction33() {
            changeSortType(gw.bubbleSort, "7,6,5,4,3,2,1");
            SORT();
        }
        function doButtonAction95() {

        }

        function adjustPopupToImageSize() {
            var width = $('#popup-image').prop('width');
            var height = $('#popup-image').prop('height');
            $('#popup').width(width + 20);
            $('#popup').height(height + 20);
            if (width == 0 && height == 0) {
                setTimeout(adjustPopupToImageSize, 200);
            } else {
                showPopup();
            }
        }

        function POPUP_IMAGE(url) {
            $('#popup-content').html('<img id="popup-image" src="' + url + '">');
            adjustPopupToImageSize();
        }

        function URL(url) {
            window.open(url, '_blank');
        }
    </script>

    <script>
        function ENTER_LECTURE_MODE() {}


        function ENTER_EXPLORE_MODE() {}


        function CUSTOM_ACTION(action, data, mode) {}
    </script>

    <script type="text/javascript">


        var Sorting = function() {

            var HIGHLIGHT_NONE = "lightblue";
            var HIGHLIGHT_STANDARD = "green";
            var HIGHLIGHT_SPECIAL = "#DC143C";
            var HIGHLIGHT_SORTED = "orange";

            var HIGHLIGHT_LEFT = "#3CB371";
            var HIGHLIGHT_RIGHT = "#9932CC";
            var HIGHLIGHT_PIVOT = "yellow";

            var HIGHLIGHT_GRAY = "#CCCCCC";

            var HIGHLIGHT_RAINBOW = [
                "#FF0000",
                "#FF4000",
                "#FF8000",
                "#FFBF00",
                "#FFFF00",
                "#BFFF00",
                "#80FF00",
                "#40FF00",

                "#00FF40",
                "#00FF80",
                "#00FFBF",
                "#00FFFF",
                "#00BFFF",
                "#0080FF",
                "#0040FF",
                "#0000FF",
                "#4000FF",
                "#8000FF",
                "#BF00FF",
                "#FF00FF"
            ];

            var HIGHLIGHT_BLUESHADES = [
                HIGHLIGHT_GRAY,
                HIGHLIGHT_NONE,
                "#9DC4E8",
                "#8EB1EB",
                "#7E9DED",
                "#6E89EF",
                "#5E76F1",
                "#4F62F4",
                "#3F4FF6",
                "#2F3BF8",
                "#1F27FA",
                "#1014FD",
                "#0000FF",
                "#0000FF",
                "#0000FF",
                "#0000FF",
                "#0000FF",
                "#0000FF",
                "#0000FF",
                "#0000FF",
                "#0000FF"
            ];

            var POSITION_USE_PRIMARY = "a";
            var POSITION_USE_SECONDARY_IN_DEFAULT_POSITION = "b";


            var Entry = function(value, highlight, position, secondaryPositionStatus) {
                this.value = value;
                this.highlight = highlight;
                this.position = position;
                this.secondaryPositionStatus = secondaryPositionStatus;
            }

            var Backlink = function(value, highlight, entryPosition, secondaryPositionStatus) {
                this.value = value;
                this.highlight = highlight;
                this.entryPosition = entryPosition;
                this.secondaryPositionStatus = secondaryPositionStatus;
            }

            var State = function(entries, backlinks, barsCountOffset, status, lineNo) {
                this.entries = entries;
                this.backlinks = backlinks;
                this.barsCountOffset = barsCountOffset;
                this.status = status;
                this.lineNo = lineNo;
            }

            var EntryBacklinkHelper = new Object();
            EntryBacklinkHelper.appendList = function(entries, backlinks, numArray) {
                for (var i = 0; i < numArray.length; i++) {
                    EntryBacklinkHelper.append(entries, backlinks, numArray[i]);
                }
            }

            EntryBacklinkHelper.append = function(entries, backlinks, newNumber) {
                entries.push(new Entry(newNumber, HIGHLIGHT_NONE, entries.length, POSITION_USE_PRIMARY));
                backlinks.push(new Backlink(newNumber, HIGHLIGHT_NONE, backlinks.length, POSITION_USE_PRIMARY));
            }

            EntryBacklinkHelper.update = function(entries, backlinks) {
                for (var i = 0; i < backlinks.length; i++) {
                    entries[backlinks[i].entryPosition].highlight = backlinks[i].highlight;
                    entries[backlinks[i].entryPosition].position = i;
                    entries[backlinks[i].entryPosition].secondaryPositionStatus = backlinks[i].secondaryPositionStatus;
                }
            }

            EntryBacklinkHelper.copyEntry = function(oldEntry) {
                return new Entry(oldEntry.value, oldEntry.highlight, oldEntry.position, oldEntry.secondaryPositionStatus);
            }

            EntryBacklinkHelper.copyBacklink = function(oldBacklink) {
                return new Backlink(oldBacklink.value, oldBacklink.highlight, oldBacklink.entryPosition, oldBacklink.secondaryPositionStatus);
            }

            EntryBacklinkHelper.swapBacklinks = function(backlinks, i, j) {
                var swaptemp = backlinks[i];
                backlinks[i] = backlinks[j];
                backlinks[j] = swaptemp;
            }

            var StateHelper = new Object();
            StateHelper.createNewState = function(numArray) {
                var entries = new Array();
                var backlinks = new Array();
                EntryBacklinkHelper.appendList(entries, backlinks, numArray);
                return new State(entries, backlinks, 0, "", 0);
            }

            StateHelper.copyState = function(oldState) {
                var newEntries = new Array();
                var newBacklinks = new Array();
                for (var i = 0; i < oldState.backlinks.length; i++) {
                    newEntries.push(EntryBacklinkHelper.copyEntry(oldState.entries[i]));
                    newBacklinks.push(EntryBacklinkHelper.copyBacklink(oldState.backlinks[i]));
                }

                var newLineNo = oldState.lineNo;
                if (newLineNo instanceof Array)
                    newLineNo = oldState.lineNo.slice();

                return new State(newEntries, newBacklinks, oldState.barsCountOffset, oldState.status, newLineNo);
            }

            StateHelper.updateCopyPush = function(list, stateToPush) {
                EntryBacklinkHelper.update(stateToPush.entries, stateToPush.backlinks);
                list.push(StateHelper.copyState(stateToPush));
            }

            var FunctionList = new Object();
            FunctionList.text_y = function(d) {
                var barHeight = scaler(d.value);
                if (barHeight < 32) return -15;
                return barHeight-15;
            }

            FunctionList.g_transform = function(d) {
                if (d.secondaryPositionStatus == POSITION_USE_PRIMARY)
                    return 'translate(' + (centreBarsOffset + d.position * barWidth) + ", " + (maxHeight - scaler(d.value)) + ')';
                else if (d.secondaryPositionStatus == POSITION_USE_SECONDARY_IN_DEFAULT_POSITION)
                    return 'translate(' + (centreBarsOffset + d.position * barWidth) + ", " + (maxHeight * 2 + gapBetweenPrimaryAndSecondaryRows - scaler(d.value)) + ')';
                else if (d.secondaryPositionStatus >= 0)
                    return 'translate(' + (centreBarsOffset + d.secondaryPositionStatus * barWidth) + ", " + (maxHeight * 2 + gapBetweenPrimaryAndSecondaryRows - scaler(d.value)) + ')';
                else if (d.secondaryPositionStatus < 0)
                    return 'translate(' + ((d.secondaryPositionStatus * -1 - 1) * barWidth) + ", " + (maxHeight * 2 + gapBetweenPrimaryAndSecondaryRows - scaler(d.value)) + ')';
                else
                    return 'translation(0, 0)';
            }

            FunctionList.radixElement_left = function(d) {
                if (d.secondaryPositionStatus == POSITION_USE_PRIMARY)
                    return d.position * 65 + centreBarsOffset + "px";
                return d.secondaryPositionStatus * 65 + 17.5 + "px";
            }

            FunctionList.radixElement_bottom = function(d, i) {
                if (d.secondaryPositionStatus == POSITION_USE_PRIMARY)
                    return 500 - 24 + "px";
                //console.log(i + " " + radixSortBucketOrdering[i]);
                return radixSortBucketOrdering[i] * 30 + 5 + "px";
            }

            FunctionList.radixElement_html = function(d) {
                if (d.highlight == HIGHLIGHT_NONE)
                    return d.value;

                var text = "" + d.value;
                while (text.length != 4)
                    text = " " + text;

                var positionToHighlight = 0;
                var positionCounter = d.highlight;
                while (positionCounter != 1) {
                    positionToHighlight++;
                    positionCounter /= 10;
                }

                positionToHighlight = 3-positionToHighlight;

                if (text.charAt(positionToHighlight) != " ") {
                    text = text.slice(0, positionToHighlight) +
                        "<span style='color: #B40404;'>" +
                        text.charAt(positionToHighlight) +
                        "</span>" +
                        text.slice(positionToHighlight+1);
                }

                text = text.trim();
                return text;
            }

            var makePaler = function(hexColor) {
                var red = Math.floor(parseInt(hexColor.slice(1, 3), 16) + 150);
                var green = Math.floor(parseInt(hexColor.slice(3, 5), 16) + 150);
                var blue = Math.floor(parseInt(hexColor.slice(5, 7), 16) + 150);

                if (red > 255) red = 255;
                if (green > 255) green = 255;
                if (blue > 255) blue = 255;

                red = red.toString(16);
                green = green.toString(16);
                blue = blue.toString(16);

                if (red.length == 1) red = "0" + red;
                if (green.length == 1) green = "0" + green;
                if (blue.length == 1) blue = "0" + blue;
                return "#" + red + green + blue;
            }


            this.currentNumList = [3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];

            var barWidth = 50;
            var maxHeight = 230;
            var gapBetweenBars = 5;
            var maxNumOfElements = 20;
            var gapBetweenPrimaryAndSecondaryRows = 30;

            var maxCountingSortElementValue = 9;
            var maxRadixSortElementValue = 9999;
            var maxElementValue = 50;

            var graphElementSize = 10;
            var graphElementGap = 2;
            var graphRowGap = 10;


            var statelist = new Array();
            var secondaryStatelist = new Array();
            var transitionTime = 500;
            var currentStep = 0;
            var animInterval;
            var issPlaying;

            var quickSortUseRandomizedPivot;
            var mergeSortInversionIndexCounter;
            var centreBarsOffset;
            var radixSortBucketOrdering;

            var isRadixSort = false;
            var isCountingSort = false;

            this.selectedSortFunction;

            this.computeInversionIndex = false;

            var canvas = d3.select("#viz-canvas")
                .attr("height", maxHeight * 2 + gapBetweenPrimaryAndSecondaryRows)
                .attr("width", barWidth * maxNumOfElements);

            var countingSortSecondaryCanvas = d3.select("#viz-counting-sort-secondary-canvas")
                .attr("height", 60)
                .attr("width", barWidth * maxNumOfElements);

            var radixSortCanvas = d3.select("#viz-radix-sort-canvas");

            var scaler = d3.scale
                .linear()
                .range([0, maxHeight]);

            var drawState = function(stateIndex) {
                if (isRadixSort)
                    drawRadixSortCanvas(statelist[stateIndex], secondaryStatelist[stateIndex]);
                else
                    drawBars(statelist[stateIndex]);

                $('#status p').html(statelist[stateIndex].status);
                highlightLine(statelist[stateIndex].lineNo);

                if (isCountingSort)
                    drawCountingSortCounters(secondaryStatelist[stateIndex]);
            };

            var drawBars = function(state) {
                scaler.domain([0, d3.max(state.entries, function(d) {
                    return d.value;
                })]);

                centreBarsOffset = (maxNumOfElements - (state.entries.length - state.barsCountOffset)) * barWidth / 2;

                var canvasData = canvas.selectAll("g").data(state.entries);


                var exitData = canvasData.exit()
                    .remove();


                var newData = canvasData.enter()
                    .append("g")
                    .attr("transform", FunctionList.g_transform);

                newData.append("rect")
                    .attr("height", 0)
                    .attr("width", 0);

                newData.append("text")
                    .attr("dy", ".35em")
                    .attr("x", (barWidth - gapBetweenBars) / 2)
                    .attr("y", FunctionList.text_y)
                    .text(function(d) {
                        return d.value;
                    });


                canvasData.select("text")
                    .transition()
                    .attr("y", FunctionList.text_y)
                    .text(function(d) {
                        return d.value;
                    });

                canvasData.select("rect")
                    .transition()
                    .attr("height", function(d) {
                        return scaler(d.value);
                    })
                    .attr("width", barWidth - gapBetweenBars)
                    .style("fill", function(d) {
                        return d.highlight;
                    });

                canvasData.transition()
                    .attr("transform", FunctionList.g_transform)
            };

            var drawCountingSortCounters = function(state) {
                var canvasData;
                if (state == null)
                    canvasData = countingSortSecondaryCanvas.selectAll("text").data([]);
                else
                    canvasData = countingSortSecondaryCanvas.selectAll("text").data(state);


                var exitData = canvasData
                    .exit()
                    .remove();



                var newData = canvasData
                    .enter()
                    .append("text")
                    .attr("dy", ".35em")
                    .attr("x", function(d, i) {
                        return (i + 5) * barWidth + (barWidth - gapBetweenBars) / 2;
                    })
                    .attr("y", 20)
                    .text(function(d) {
                        return d;
                    });


                canvasData
                    .transition()
                    .text(function(d) {
                        return d;
                    });
            };

            var drawRadixSortCanvas = function(state, secondaryState) {
                centreBarsOffset = (1000 - (state.entries.length * 65 - 10)) / 2;

                var canvasData = radixSortCanvas.selectAll("div").data(state.entries);
                var radixSortBucketCount = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                radixSortBucketOrdering = new Array(state.backlinks.length);

                for (var i = 0; i < state.backlinks.length; i++) {
                    if (state.backlinks.secondaryPositionStatus != POSITION_USE_PRIMARY)
                        radixSortBucketOrdering[state.backlinks[i].entryPosition] = radixSortBucketCount[state.backlinks[i].secondaryPositionStatus]++;
                }

                if (secondaryState)
                    $("#radix-sort-bucket-labels-collection").show();
                else
                    $("#radix-sort-bucket-labels-collection").hide();

                var exitData = canvasData.exit()
                    .remove();

                var newData = canvasData.enter()
                    .append("div")
                    .classed({"radix-sort-element": true})
                    .style({
                        "left": FunctionList.radixElement_left,
                        "bottom": FunctionList.radixElement_bottom
                    })
                    .html(FunctionList.radixElement_html);


                canvasData.html(FunctionList.radixElement_html)
                    .transition()
                    .style({
                        "left": FunctionList.radixElement_left,
                        "bottom": FunctionList.radixElement_bottom
                    });
            };

            var generateRandomNumberArray = function(size, limit) {
                var numArray = new Array();
                for (var i = 0; i < size; i++) {
                    numArray.push(generateRandomNumber(1, limit));
                }
                return numArray;
            };

            var generateRandomNumber = function(min, max) {
                return Math.floor(Math.random() * (max - min + 1)) + min;
            };

            var convertToNumber = function(num) {
                return +num;
            };

            this.createList = function(type) {
                var numArrayMaxListSize = 20;
                var numArrayMaxElementValue = maxElementValue;
                if (this.selectedSortFunction == this.radixSort) {
                    numArrayMaxListSize = 15;
                    numArrayMaxElementValue = maxRadixSortElementValue;
                }
                else if (this.selectedSortFunction == this.countingSort) {
                    numArrayMaxElementValue = maxCountingSortElementValue;
                }

                var numArray = generateRandomNumberArray(generateRandomNumber(10, numArrayMaxListSize), numArrayMaxElementValue);

                switch (type) {
                    case 'userdefined':
                        numArray = $('#userdefined-input').val().split(",");

                        if (numArray.length > numArrayMaxListSize) {
                            $("#create-err").html('<span style="white-space: normal;">&nbsp;你不能够有多于{maxSize} 个元素！&nbsp;</span>'.replace("{maxSize}", numArrayMaxListSize));
                            return false;
                        }

                        for (var i = 0; i < numArray.length; i++) {
                            var temp = convertToNumber(numArray[i]);

                            if (numArray[i].trim() == "") {
                                $("#create-err").html('似乎缺少了一个元素（也许某个地方有重复的逗号？）');
                                return false;
                            }
                            if (isNaN(temp)) {
                                $("#create-err").html('<span style="white-space: normal;">&nbsp;似乎有一个无效的元素（非数字）{num}</span>'.replace("{num}", numArray[i]));
                                return false;
                            }
                            if (temp < 1 || temp > numArrayMaxElementValue) {
                                $("#create-err").html('抱歉，值域限制在1和<span style="white-space: normal;">&nbsp;{maxValue} 之间（包括两界）。（超出值域的值: {num} ）</span>'.replace("{maxValue}", numArrayMaxElementValue).replace("{num}", numArray[i]));
                                return false;
                            }

                            numArray[i] = convertToNumber(numArray[i]);
                        }
                        break;
                    case 'random':
                        break;
                    case 'sorted-increasing':
                    case 'nearly-sorted-increasing':
                        numArray.sort(d3.ascending);
                        break;
                    case 'sorted-decreasing':
                    case 'nearly-sorted-decreasing':
                        numArray.sort(d3.descending);
                        break;
                }

                if (type.indexOf("nearly") != -1) {

                    while (true) {
                        var newNumArray = numArray.slice();

                        var numOfSwaps = generateRandomNumber(1, 2);
                        for (var i = 0; i < numOfSwaps; i++) {
                            var firstSwappingIndex = generateRandomNumber(0, newNumArray.length - 4);
                            var secondSwappingIndex = generateRandomNumber(1, 3) + firstSwappingIndex;

                            var temp = numArray[firstSwappingIndex];
                            newNumArray[firstSwappingIndex] = numArray[secondSwappingIndex];
                            newNumArray[secondSwappingIndex] = temp;
                        }


                        var isEquals = true;
                        for (var i = 0; i < numArray.length; i++) {
                            if (numArray[i] != newNumArray[i]) {
                                isEquals = false;
                                break;
                            }
                        }

                        if (!isEquals) {
                            numArray = newNumArray;
                            break;
                        }
                    }
                }

                this.loadNumberList(numArray);
            }

            this.loadNumberList = function(numArray) {
                $("#create-err").html("");

                issPlaying = false;
                currentStep = 0;
                this.currentNumList = numArray;



                statelist = [StateHelper.createNewState(numArray)];
                secondaryStatelist = [null];
                drawState(0);
            }

            this.setSelectedSortFunction = function(f) {
                this.selectedSortFunction = f;
                isRadixSort = (this.selectedSortFunction == this.radixSort);
                isCountingSort = (this.selectedSortFunction == this.countingSort);
            }

            this.sort = function(callback) {
                return this.selectedSortFunction(callback);
            }

            this.radixSort = function(callback) {
                var numElements = statelist[0].backlinks.length;
                var state = StateHelper.copyState(statelist[0]);

                populatePseudocode([
                    '创建10个桶（队列<span style="font-size: 13px;">）分别给每个数位（0到9）</span>',
                    '遍历每个数位',
                    '遍历数列中的每个元素',
                    '将元素移至相应的桶中',
                    '在每个桶中，从最小的数位开始',
                    '当桶不是空的',
                    '将元素恢复至数列中'
                ]);

                secondaryStatelist = [false];
                var currentPlacing = 1;
                var targetPlacing = 1;
                var backlinkBuckets = [[], [], [], [], [], [], [], [], [], []];

                var maxValue = d3.max(state.backlinks, function(d) {
                    return d.value;
                });
                while (maxValue >= 10) {
                    targetPlacing *= 10;
                    maxValue = Math.floor(maxValue / 10);
                }

                for (; currentPlacing <= targetPlacing; currentPlacing *= 10) {
                    for (var i = 0; i < numElements; i++)
                        state.backlinks[i].highlight = currentPlacing;

                    StateHelper.updateCopyPush(statelist, state);
                    secondaryStatelist.push(true);

                    for (var i = 0; i < numElements; i++) {
                        var currentDigit = Math.floor(state.backlinks[i].value / currentPlacing) % 10;
                        state.backlinks[i].secondaryPositionStatus = currentDigit;
                        backlinkBuckets[currentDigit].push(state.backlinks[i]);
                        StateHelper.updateCopyPush(statelist, state);
                        secondaryStatelist.push(true);
                    }

                    for (var i = 0, j = 0; i <= 9; ) {
                        if (backlinkBuckets[i].length == 0) {
                            i++;
                            continue;
                        }

                        state.backlinks[j++] = backlinkBuckets[i].shift();
                    }

                    for (var i = 0; i < numElements; i++) {
                        state.backlinks[i].secondaryPositionStatus = POSITION_USE_PRIMARY;
                        StateHelper.updateCopyPush(statelist, state);
                        secondaryStatelist.push(true);
                    }
                }

                for (var i = 0; i < numElements; i++)
                    state.backlinks[i].highlight = HIGHLIGHT_NONE;
                StateHelper.updateCopyPush(statelist, state);
                secondaryStatelist.push(false);

                this.play(callback);
                return true;
            }

            this.countingSort = function(callback) {


                var numElements = statelist[0].backlinks.length;
                var state = StateHelper.copyState(statelist[0]);

                populatePseudocode([
                    '创建关键值（计数）数组',
                    '遍历数列中的每个元素',
                    '相应的计数器增加1',
                    '每轮计数，都从最小的值开始',
                    '当计数为非零数时循环',
                    '重新将元素存储于列表',
                    '将计数减1'
                ]);

                var secondaryState = [0, 0, 0, 0, 0, 0, 0, 0, 0];
                var backlinkBuckets = [[], [], [], [], [], [], [], [], []];

                state.barsCountOffset = maxCountingSortElementValue;

                for (var i = 1; i <= maxCountingSortElementValue; i++) {
                    EntryBacklinkHelper.append(state.entries, state.backlinks, i);
                    state.backlinks[numElements + i - 1].highlight = HIGHLIGHT_GRAY;
                    state.backlinks[numElements + i - 1].secondaryPositionStatus = i * -1 - 5;
                }

                state.lineNo = 1;
                state.status = '创建一个关键值（计数）数组（从1到9）.';

                StateHelper.updateCopyPush(statelist, state);
                secondaryStatelist.push(secondaryState.slice()); // copy the array and push it into the secondary statelist

                for (var i = 0; i < numElements; i++) {
                    var currentValue = state.backlinks[i].value;

                    backlinkBuckets[currentValue-1].push(state.backlinks[i]);

                    state.backlinks[i].secondaryPositionStatus = currentValue * -1 - 5;

                    secondaryState[currentValue-1]++;

                    state.backlinks[currentValue + numElements - 1].highlight = HIGHLIGHT_BLUESHADES[secondaryState[currentValue - 1]];

                    state.lineNo = [2, 3];
                    state.status = '将'.replace("{curVal}", currentValue);

                    StateHelper.updateCopyPush(statelist, state);
                    secondaryStatelist.push(secondaryState.slice());
                }

                for (var i = 0, j = 0; i < maxCountingSortElementValue; ) {
                    if (backlinkBuckets[i].length == 0) {
                        i++;
                        continue;
                    }

                    state.backlinks[j++] = backlinkBuckets[i].shift();
                }

                for (var i = 0; i < numElements; i++) {
                    var currentValue = state.backlinks[i].value;

                    state.backlinks[i].secondaryPositionStatus = POSITION_USE_PRIMARY;

                    secondaryState[currentValue - 1]--;

                    state.backlinks[currentValue + numElements - 1].highlight = HIGHLIGHT_BLUESHADES[secondaryState[currentValue - 1]];

                    state.lineNo = [4, 5, 6, 7];
                    state.status = '重新存储元素&nbsp;{curVal}, 并且将值为 {curVal} 的计数减&nbsp;1.'.replace("{curVal}", currentValue);

                    StateHelper.updateCopyPush(statelist, state);
                    secondaryStatelist.push(secondaryState.slice());
                }

                state.barsCountOffset = 0;

                for (var i = 1; i <= maxCountingSortElementValue; i++) {
                    state.entries.pop();
                    state.backlinks.pop();
                }

                state.lineNo = 0;
                state.status = '排序完成!';
                StateHelper.updateCopyPush(statelist, state);
                secondaryStatelist.push(null);

                this.play(callback);
                return true;
            }

            this.randomizedQuickSort = function(callback) {
                quickSortUseRandomizedPivot = true;
                quickSortStart();

                this.play(callback);
                return true;
            }

            this.quickSort = function(callback) {
                quickSortUseRandomizedPivot = false;
                quickSortStart();

                this.play(callback);
                return true;
            }

            var quickSortStart = function() {
                var numElements = statelist[0].backlinks.length;
                var state = StateHelper.copyState(statelist[statelist.length - 1]);

                populatePseudocode([
                    '每个（未排序）的拆分的遍历',
                    (quickSortUseRandomizedPivot) ? '随机选取轴心点，和第一个元素交换' : '将第一个元素设为轴心点',
                    '  存储指数 = 轴心点指数 +1',
                    '  从 i=轴心点指数 +1 到 最右指数 的遍历',
                    '    如果 元素[i] &lt; 元素[轴心点]',
                    '      交换(i, 存储指数); 存储指数++',
                    '  交换(轴心点, 存储指数&nbsp;- 1)'
                ]);

                quickSortSplit(state, 0, numElements - 1);

                state.lineNo = 0;
                state.status = '排序完成!';

                for (var i = 0; i < numElements; i++)
                    state.backlinks[i].highlight = HIGHLIGHT_NONE;
                StateHelper.updateCopyPush(statelist, state);
            }

            var quickSortSplit = function(state, startIndex, endIndex) {
                state.status = '进行拆分&nbsp;[{partition}] (指数从&nbsp;{startIndex} 到 {endIndex} ，两边皆包括).'
                    .replace("{partition}", state.backlinks.slice(startIndex, endIndex + 1).map(function(d) {
                        return d.value;
                    }))
                    .replace("{startIndex}", startIndex).replace("{endIndex}", endIndex);
                state.lineNo = 1;

                if (startIndex > endIndex)
                    return;

                if (startIndex == endIndex) {
                    state.status += ' 因为拆分大小 == 1，在拆分项中的元素一定会在排序过后的位置。';
                    state.backlinks[startIndex].highlight = HIGHLIGHT_SORTED;
                    StateHelper.updateCopyPush(statelist, state);
                    return;
                }

                var middleIndex = quickSortPartition(state, startIndex, endIndex);
                quickSortSplit(state, startIndex, middleIndex - 1);
                quickSortSplit(state, middleIndex + 1, endIndex);
            }

            var quickSortPartition = function(state, startIndex, endIndex) {

                var pivotIndex;
                if (quickSortUseRandomizedPivot) {

                    pivotIndex = generateRandomNumber(startIndex, endIndex);

                    state.status += ' 随机选取&nbsp;{pivot} (指数为&nbsp;{index}) 作为轴心点'.replace("{pivot}", state.backlinks[pivotIndex].value).replace("{index}", pivotIndex);
                    state.lineNo = [1, 2];

                    state.backlinks[pivotIndex].highlight = HIGHLIGHT_PIVOT;
                    StateHelper.updateCopyPush(statelist, state);

                    if (pivotIndex != startIndex) {
                        state.status = '交换轴心点&nbsp;({pivot}}, 指数为&nbsp;{index}) 和第一个元素&nbsp;({first}, 指数 {firstIndex}). (存储指数= {storeIndex}.)'.replace("{pivot}", state.backlinks[pivotIndex].value).replace("{index}", pivotIndex)
                            .replace("{first}", state.backlinks[startIndex].value).replace("{firstIndex}", startIndex).replace("{storeIndex}", (startIndex + 1));

                        state.lineNo = [2, 3];

                        EntryBacklinkHelper.swapBacklinks(state.backlinks, pivotIndex, startIndex);
                        pivotIndex = startIndex;
                        StateHelper.updateCopyPush(statelist, state);
                    }
                }
                else {
                    pivotIndex = startIndex;

                    state.status += ' 选择 {pivot} 作为轴心点. (存储指数&nbsp;= {storeIndex}.)'.replace("{pivot}", state.backlinks[pivotIndex].value).replace("{storeIndex}", (startIndex + 1));
                    state.lineNo = [1, 2, 3];

                    state.backlinks[pivotIndex].highlight = HIGHLIGHT_PIVOT;
                    StateHelper.updateCopyPush(statelist, state);
                }

                var storeIndex = pivotIndex + 1;
                var pivotValue = state.backlinks[pivotIndex].value;

                for (var i = storeIndex; i <= endIndex; i++) {
                    state.status = '检查是否&nbsp;{val} &lt; {pivot} (轴心点).'.replace("{val}", state.backlinks[i].value).replace("{pivot}", pivotValue);
                    state.lineNo = [4, 5];

                    state.backlinks[i].highlight = HIGHLIGHT_SPECIAL;
                    StateHelper.updateCopyPush(statelist, state);
                    if (state.backlinks[i].value < pivotValue) {
                        state.status = '{val} &lt; {pivot} (轴心点) 是真（True）. 将指数为&nbsp;{idx} (值&nbsp;= {val}) 和在存储指数的元素&nbsp;(指数&nbsp;= {storeIdx}, 值 = {storeVal}) 进行交换. (交换过后在存储指数上的值&nbsp;= {newStoreIdx}).'.replace("{val}", state.backlinks[i].value).replace("{pivot}", pivotValue)
                            .replace("{idx}", i).replace("{storeIdx}", storeIndex).replace("{storeVal}", state.backlinks[storeIndex].value).replace("newStoreIdx", (storeIndex + 1));
                        state.lineNo = [4, 6];

                        if (i != storeIndex) {
                            EntryBacklinkHelper.swapBacklinks(state.backlinks, storeIndex, i);
                            StateHelper.updateCopyPush(statelist, state);
                        }

                        state.backlinks[storeIndex].highlight = HIGHLIGHT_LEFT;
                        storeIndex++;
                    }
                    else {
                        state.backlinks[i].highlight = HIGHLIGHT_RIGHT;
                    }
                }
                state.status = '遍历完成。<br>';
                state.lineNo = 4;
                StateHelper.updateCopyPush(statelist, state);
                if (storeIndex - 1 != pivotIndex) {
                    state.status = '将轴心点（指数= {pivotIdx}, 值 = {pivot}) 和在存储指数-1 的元素 (指数 = {newIdx}, 值 = {newVal}) 进行交换）<br>'.replace("{pivotIdx}", pivotIndex).replace("{pivot}", pivotValue)
                        .replace("{newIdx}", (storeIndex - 1)).replace("{newVal}", state.backlinks[storeIndex - 1].value);
                    state.lineNo = 7;
                    EntryBacklinkHelper.swapBacklinks(state.backlinks, storeIndex - 1, pivotIndex);
                    StateHelper.updateCopyPush(statelist, state);
                }

                state.status = '现在轴心点已经在排序过后的位置<br>';
                state.lineNo = 7;

                for (var i = startIndex; i <= endIndex; i++)
                    state.backlinks[i].highlight = HIGHLIGHT_NONE; //unhighlight everything
                state.backlinks[storeIndex - 1].highlight = HIGHLIGHT_SORTED;
                StateHelper.updateCopyPush(statelist, state);

                return storeIndex - 1;
            }

            this.mergeSort = function(callback) {
                var numElements = statelist[0].backlinks.length;
                var state = StateHelper.copyState(statelist[0]);

                populatePseudocode([
                    '将每个元素拆分成大小为1的部分',
                    '递归的合并相邻的拆分项',
                    '  i = 左侧开始项指数 到 右侧最后项指数 的遍历（两端包括）',
                    '    如果左侧首值 &lt;= 右侧首值',
                    '      拷贝左侧首项的值<br>',
                    '    否则： 拷贝右侧部分首值' + ((this.computeInversionIndex) ? '；增加倒置指数' : ""),
                    '将元素拷贝进原来的数组中'
                ]);

                mergeSortInversionIndexCounter = 0;

                for (var i = 0; i < numElements; i++) {
                    state.backlinks[i].highlight = HIGHLIGHT_RAINBOW[i];
                }

                state.status = '我们将数组拆分成每项只有一个元素（每个拆分项有一个独特的颜色）';
                status.lineNo = 1;
                StateHelper.updateCopyPush(statelist, state);

                this.mergeSortSplitMerge(state, 0, numElements);

                for (var i = 0; i < numElements; i++)
                    state.backlinks[i].highlight = HIGHLIGHT_NONE; //unhighlight everything

                state.status = '排序完成!';
                if (this.computeInversionIndex) {
                    state.status += ' （倒置指数 = {idx}）<br>'.replace("{idx}", mergeSortInversionIndexCounter);
                }

                state.lineNo = 0;
                StateHelper.updateCopyPush(statelist, state);

                this.play(callback);
                return true;
            }

            this.mergeSortSplitMerge = function(state, startIndex, endIndex) {
                if (endIndex - startIndex <= 1)
                    return;

                var middleIndex = Math.ceil((startIndex + endIndex) / 2);
                this.mergeSortSplitMerge(state, startIndex, middleIndex);
                this.mergeSortSplitMerge(state, middleIndex, endIndex);
                this.mergeSortMerge(state, startIndex, middleIndex, endIndex)

                state.status = '我们将新数组中的元素拷贝回原来的数组中。<br>';
                state.lineNo = 7;

                var duplicateBacklinks = new Array();
                for (var i = startIndex; i < endIndex; i++) {
                    var newPosition = state.backlinks[i].secondaryPositionStatus;
                    duplicateBacklinks[newPosition] = state.backlinks[i];
                }

                for (var i = startIndex; i < endIndex; i++) {
                    state.backlinks[i] = duplicateBacklinks[i];
                }

                for (var i = startIndex; i < endIndex; i++) {
                    state.backlinks[i].secondaryPositionStatus = POSITION_USE_PRIMARY;
                    StateHelper.updateCopyPush(statelist, state);
                }
            }

            this.mergeSortMerge = function(state, startIndex, middleIndex, endIndex) {
                var leftIndex = startIndex;
                var rightIndex = middleIndex;

                var newHighlightColor = state.backlinks[startIndex].highlight;

                state.status = '现在我们将拆分项 [{partition1}] (指数从 {startIdx1} 到 {endIdx1}，两边都包括) 和 [{partition2}] 指数从 {startIdx2} 到 {endIdx2} ，两边都包括) 合并在一起。<br>'
                    .replace('{partition1}', state.backlinks.slice(startIndex, middleIndex).map(function(d) {
                        return d.value;
                    }))
                    .replace("{startIdx1}", startIndex).replace("{endIdx1}", (middleIndex - 1))
                    .replace("{partition2}", state.backlinks.slice(middleIndex, endIndex).map(function(d) {
                        return d.value;
                    }))
                    .replace("{startIdx2}", middleIndex).replace("{endIdx2}", (endIndex - 1));
                state.lineNo = 2;

                state.backlinks[leftIndex].highlight = makePaler(state.backlinks[leftIndex].highlight);
                state.backlinks[rightIndex].highlight = makePaler(state.backlinks[rightIndex].highlight);
                StateHelper.updateCopyPush(statelist, state);

                for (var i = startIndex; i < endIndex; i++) {

                    if (leftIndex < middleIndex && (rightIndex >= endIndex || state.backlinks[leftIndex].value <= state.backlinks[rightIndex].value)) {
                        state.backlinks[leftIndex].highlight = newHighlightColor;
                        state.backlinks[leftIndex].secondaryPositionStatus = i;

                        if (rightIndex < endIndex) {
                            state.status = '因为 {leftPart} (左拆分) &lt;= {rightPart} (右拆分), 我们将&nbsp;{rightPart} 拷进新的数组。<br>'
                                .replace("{leftPart}", state.backlinks[leftIndex].value).replace("{rightPart}", state.backlinks[rightIndex].value);
                        }
                        else {
                            state.status = '因为右拆分是空的，我们将{leftPart} (左拆分) 拷贝进新的数组。'.replace("{leftPart}", state.backlinks[leftIndex].value);
                        }
                        state.lineNo = [3, 4, 5];

                        leftIndex++;
                        if (leftIndex != middleIndex)
                            state.backlinks[leftIndex].highlight = makePaler(state.backlinks[leftIndex].highlight);

                        StateHelper.updateCopyPush(statelist, state);
                    }
                    else {
                        state.backlinks[rightIndex].highlight = newHighlightColor;
                        state.backlinks[rightIndex].secondaryPositionStatus = i;

                        if (leftIndex < middleIndex) {
                            state.status = '<span style="font-size: 13px;">因为 {leftPart} (左拆分) &gt; {rightPart} (右拆分), 我们将&nbsp;{rightPart} 拷进新的数组。</span><br>'
                                .replace("{leftPart}", state.backlinks[leftIndex].value).replace("{rightPart}", state.backlinks[rightIndex].value);
                        }
                        else {
                            state.status = '因为左拆分是空的，我们将&nbsp;{rightPart}&nbsp; （右拆分）拷进新的数组。'.replace("{rightPart}", state.backlinks[rightIndex].value);
                        }

                        if (this.computeInversionIndex) {
                            mergeSortInversionIndexCounter += middleIndex - leftIndex;
                            state.status += '(我们将左拆分的大小 (= {sizeofleft}) 加至倒置指数 ({inversionidxcounter}).)<br>'
                                .replace("{sizeofleft}", (middleIndex - leftIndex)).replace("{inversionidxcounter}", mergeSortInversionIndexCounter);
                        }
                        else {
                            state.status += 'wierd';
                        }
                        state.lineNo = [3, 6];

                        rightIndex++;
                        if (rightIndex != endIndex)
                            state.backlinks[rightIndex].highlight = makePaler(state.backlinks[rightIndex].highlight);

                        StateHelper.updateCopyPush(statelist, state);
                    }
                }
            }

            this.insertionSort = function(callback) {
                var numElements = statelist[0].backlinks.length;
                var state = StateHelper.copyState(statelist[0]);

                populatePseudocode([
                    '将第一个元素标记为已排序',
                    'for each unsorted element X',
                    '  &#39;extract&#39; the element X',
                    '  for j = lastSortedIndex down to 0',
                    '    if current element j &gt; X',
                    '      将排序过的元素向右移一格',
                    '    break loop and insert X here'
                ]);


                state.lineNo = 1;

                state.status = '将第一个元素&nbsp;({firstVal}) 标记为已经排序过。'.replace("{firstVal}", state.backlinks[0].value);
                state.backlinks[0].highlight = HIGHLIGHT_SORTED;
                StateHelper.updateCopyPush(statelist, state);

                for (var i = 1; i < numElements; i++) {
                    state.lineNo = [2, 3];
                    state.status = '提取第一个没有排序过的元素&nbsp;({val})。'.replace("{val}", state.backlinks[i].value);
                    state.backlinks[i].highlight = HIGHLIGHT_SPECIAL;
                    state.backlinks[i].secondaryPositionStatus = POSITION_USE_SECONDARY_IN_DEFAULT_POSITION;
                    StateHelper.updateCopyPush(statelist, state);

                    for (var j = i-1; j >= 0; j--) {
                        state.lineNo = 4;

                        state.status = '找出插入提取元素的地方；和已经排序过的元素 {val} 比较。'.replace("{val}", state.backlinks[j].value);;
                        state.backlinks[j].highlight = HIGHLIGHT_STANDARD;
                        StateHelper.updateCopyPush(statelist, state);

                        if (state.backlinks[j].value > state.backlinks[j+1].value) {
                            state.lineNo = [5, 6];

                            state.status = '{val1} &gt; {val2} 成立（True）, &nbsp;则将现在已经排序过的元素</span><span style="white-space: normal;">({val1}) 向右移动1格。'.replace("{val1}", state.backlinks[j].value).replace("{val2}", state.backlinks[j+1].value);
                            EntryBacklinkHelper.swapBacklinks(state.backlinks, j, j+1);
                            StateHelper.updateCopyPush(statelist, state);
                            state.backlinks[j+1].highlight = HIGHLIGHT_SORTED;
                        }
                        else {
                            state.lineNo = 7;

                            state.status = '{val1} &gt; {val2} 不成立（False）, 在现有位置上插入一个元素。'.replace("{val1}", state.backlinks[j].value).replace("{val2}", state.backlinks[j+1].value);
                            state.backlinks[j].highlight = HIGHLIGHT_SORTED;
                            state.backlinks[j+1].secondaryPositionStatus = POSITION_USE_PRIMARY;
                            state.backlinks[j+1].highlight = HIGHLIGHT_SORTED;
                            StateHelper.updateCopyPush(statelist, state);
                            break;
                        }
                    }

                    if (state.backlinks[0].secondaryPositionStatus == POSITION_USE_SECONDARY_IN_DEFAULT_POSITION) {
                        state.lineNo = 4;

                        state.status = '在数组的最开始（没有东西可以比较），则在现有位置上插入元素。';
                        state.backlinks[0].secondaryPositionStatus = POSITION_USE_PRIMARY;
                        state.backlinks[0].highlight = HIGHLIGHT_SORTED;
                        StateHelper.updateCopyPush(statelist, state);
                    }
                }

                for (var i = 0; i < numElements; i++)
                    state.backlinks[i].highlight = HIGHLIGHT_NONE; //unhighlight everything
                state.lineNo = 0;

                state.status = '排序完成!';
                StateHelper.updateCopyPush(statelist, state);

                this.play(callback);
                return true;
            }

            this.selectionSort = function(callback) {
                var numElements = statelist[0].backlinks.length;
                var state = StateHelper.copyState(statelist[0]);

                populatePseudocode([
                    '重复（元素个数-1）次',
                    '  把第一个没有排序过的元素设置为最小值',
                    '  遍历每个没有排序过的元素',
                    '    如果元素 &lt; 现在的最小值',
                    '      将此元素设置成为新的最小值',
                    '  将最小值和第一个没有排序过的位置交换'
                ]);

                for (var i = 0; i < numElements-1; i++) {
                    var minPosition = i;


                    state.status = '循环 {iteration}: 把现在的最小值设置成为&nbsp;{val} , 然后通过遍历剩下的没有排序过的元素来找到真正的最小值。'.replace("{iteration}", (i+1)).replace("{val}", state.backlinks[i].value);
                    state.lineNo = [1, 2, 3];
                    state.backlinks[minPosition].highlight = HIGHLIGHT_SPECIAL;

                    StateHelper.updateCopyPush(statelist, state);

                    for (var j = i+1; j < numElements; j++) {

                        state.status = '检查是否&nbsp;{val} 小于现在的最小值&nbsp;({minVal})。'.replace("{val}", state.backlinks[j].value).replace("{minVal}", state.backlinks[minPosition].value);
                        state.lineNo = 4;
                        state.backlinks[j].highlight = HIGHLIGHT_STANDARD;
                        StateHelper.updateCopyPush(statelist, state);

                        state.backlinks[j].highlight = HIGHLIGHT_NONE;

                        if (state.backlinks[j].value < state.backlinks[minPosition].value) {
                            state.status = '将 {val} 设为新的最小值。'.replace("{val}", state.backlinks[j].value);
                            state.lineNo = 5;
                            state.backlinks[minPosition].highlight = HIGHLIGHT_NONE;
                            state.backlinks[j].highlight = HIGHLIGHT_SPECIAL;

                            minPosition = j;
                            StateHelper.updateCopyPush(statelist, state);
                        }
                    }

                    if (minPosition != i) {

                        state.status = '交换最小的元素&nbsp;({minVal}) 和第一个没有排序过的元素&nbsp;({element})。'.replace("{minVal}", state.backlinks[minPosition].value).replace("{element}", state.backlinks[i].value);
                        state.lineNo = 6;
                        state.backlinks[i].highlight = HIGHLIGHT_SPECIAL;
                        StateHelper.updateCopyPush(statelist, state);

                        EntryBacklinkHelper.swapBacklinks(state.backlinks, minPosition, i);
                        StateHelper.updateCopyPush(statelist, state);
                    }
                    else {

                        state.status = '因为最小值是第一个非排序过的元素，没有必要进行交换。';
                        state.lineNo = 6;
                        StateHelper.updateCopyPush(statelist, state);
                    }


                    state.status = '现在 {val} 被认为是排序过的了。'.replace("{val}", state.backlinks[i].value);
                    state.backlinks[minPosition].highlight = HIGHLIGHT_NONE;
                    state.backlinks[i].highlight = HIGHLIGHT_SORTED;
                    StateHelper.updateCopyPush(statelist, state);
                }

                for (var i = 0; i < numElements; i++)
                    state.backlinks[i].highlight = HIGHLIGHT_NONE;

                state.status = '排序完成!' + '<br>' + '（所有循环过后，最后一个元素自然就被排序过了）';
                status.lineNo = 0;
                StateHelper.updateCopyPush(statelist, state);

                this.play(callback);
                return true;
            }

            this.bubbleSort = function(callback) {
                var numElements = statelist[0].backlinks.length;
                var state = StateHelper.copyState(statelist[0]);
                var swapCounter = 0;

                populatePseudocode([
                    '做',
                    '  交换旗帜变量 = 假 （False）',
                    '  for i = 1 to indexOfLastUnsortedElement-1',
                    '    如果 左边元素 &gt; 右边元素',
                    '      交换（左边元素，右边元素）',
                    '      交换旗帜变量 = 真（True）' + ((this.computeInversionIndex) ? '; 交换计数器++' : ""),
                    'while 交换旗帜变量'
                ]);

                var swapped;
                var indexOfLastUnsortedElement = numElements;
                do {
                    swapped = false;


                    state.status = 'Set the swapped flag to false.<div>Then iterate from 1 to {endIdx} inclusive.</div>'.replace("{endIdx}", indexOfLastUnsortedElement-1);
                    state.lineNo = [2, 3];
                    StateHelper.updateCopyPush(statelist, state);

                    for (var i = 1; i < indexOfLastUnsortedElement; i++) {
                        state.backlinks[i-1].highlight = HIGHLIGHT_STANDARD;
                        state.backlinks[i].highlight = HIGHLIGHT_STANDARD;


                        state.status = '<div>Checking if {val1} &gt; {val2} and swap them if that is true.</div>The current value of swapped = {swapped}.'.replace("{val1}", state.backlinks[i-1].value).replace("{val2}", state.backlinks[i].value).replace("{swapped}", swapped);
                        state.lineNo = 4;
                        StateHelper.updateCopyPush(statelist, state);

                        if (state.backlinks[i-1].value > state.backlinks[i].value) {
                            swapped = true;


                            state.status = 'Swapping the positions of {val1} and {val2}.<div>Set swapped = true.</div>'.replace("{val1}", state.backlinks[i-1].value).replace("{val2}", state.backlinks[i].value);
                            if (this.computeInversionIndex) {
                                swapCounter++;

                                state.status += ' For inversion index: Add 1 to swapCounter.<div>Current value of swapCounter = {swapCounter}.</div>'.replace("{swapCounter}", swapCounter);
                            }

                            state.lineNo = [5, 6];

                            EntryBacklinkHelper.swapBacklinks(state.backlinks, i, i-1);
                            StateHelper.updateCopyPush(statelist, state);
                        }

                        state.backlinks[i-1].highlight = HIGHLIGHT_NONE;
                        state.backlinks[i].highlight = HIGHLIGHT_NONE;
                    }

                    indexOfLastUnsortedElement--;
                    state.backlinks[indexOfLastUnsortedElement].highlight = HIGHLIGHT_SORTED;
                    if (swapped == false)

                        state.status = 'No swap is done in this pass.<div>We can terminate Bubble Sort now</div>';
                    else

                        state.status = '<div>Mark last unsorted element as sorted now.</div><div>As at least one swap is done in this pass, we continue.</div>';

                    state.lineNo = 7;
                    StateHelper.updateCopyPush(statelist, state);
                }
                while (swapped);

                for (var i = 0; i < numElements; i++)
                    state.backlinks[i].highlight = HIGHLIGHT_NONE; //un-highlight everything


                state.status = '排序完成!';
                if (this.computeInversionIndex)

                    state.status += ' Inversion Index = {swapCounter}.'.replace("swapCounter", swapCounter);

                state.lineNo = 0;
                StateHelper.updateCopyPush(statelist, state);

                this.play(callback);
                return true;
            }

            this.clearPseudocode = function() { populatePseudocode([]); }

            var populatePseudocode = function(code) {
                var i = 1;
                for (; i <= 7 && i <= code.length; i++) {
                    $("#code" + i).html(
                        code[i - 1].replace(
                            /^\s+/,
                            function(m) { return m.replace(/\s/g, "&nbsp;"); }
                        )
                    );
                }
                for (; i <= 7; i++) {
                    $("#code" + i).html("");
                }
            }

            var drawCurrentState = function() {
                $('#progress-bar').slider("value", currentStep);
                drawState(currentStep);
                if (currentStep == (statelist.length-1)) {
                    pause();
                    $('#play img').attr('src', 'replay.png').attr('alt', 'replay').attr('title', 'replay');
                }
                else
                    $('#play img').attr('src', 'play.png').attr('alt', 'play').attr('title', 'play');
            }

            this.getAnimationDuration = function() { return transitionTime; }

            this.setAnimationDuration = function(x) {
                transitionTime = x;
                if (issPlaying) {
                    clearInterval(animInterval);
                    animInterval = setInterval(function() {
                        drawCurrentState();
                        if (currentStep < (statelist.length-1))
                            currentStep++;
                        else
                            clearInterval(animInterval);
                    }, transitionTime);
                }
            }

            this.getCurrentIteration = function() { return currentStep; }

            this.getTotalIteration = function() { return statelist.length; }

            this.forceNext = function() {
                if ((currentStep + 1) < statelist.length)
                    currentStep++;
                drawCurrentState();
            }

            this.forcePrevious = function() {
                if ((currentStep-1) >= 0)
                    currentStep--;
                drawCurrentState();
            }

            this.jumpToIteration = function(n) {
                currentStep = n;
                drawCurrentState();
            }

            this.play = function(callback) {
                issPlaying = true;
                drawCurrentState();
                animInterval = setInterval(function() {
                    drawCurrentState();
                    if (currentStep < (statelist.length-1))
                        currentStep++;
                    else {
                        clearInterval(animInterval);
                        if (typeof callback == 'function') callback();
                    }
                }, transitionTime);
            }

            this.pause = function() {
                issPlaying = false;
                clearInterval(animInterval);
            }

            this.replay = function() {
                issPlaying = true;
                currentStep = 0;
                drawCurrentState();
                animInterval = setInterval(function() {
                    drawCurrentState();
                    if (currentStep < (statelist.length-1))
                        currentStep++;
                    else
                        clearInterval(animInterval);
                }, transitionTime);
            }

            this.stop = function() {
                issPlaying = false;
                statelist = [statelist[0]];
                secondaryStatelist = [null];
                currentStep = 0;
                drawState(0);
            }
        }
        var actionsWidth = 150;
        var statusCodetraceWidth = 420;

        var isCreateOpen = false;
        var isInsertOpen = false;
        var isRemoveOpen = false;
        var isSortOpen = false;

        function openCreate() {
            if (!isCreateOpen) {
                $('.create').fadeIn('fast');
                isCreateOpen = true;
            }
        }

        function closeCreate() {
            if (isCreateOpen) {
                $('.create').fadeOut('fast');
                $('#create-err').html("");
                isCreateOpen = false;
            }
        }

        function openInsert() {
            if (!isInsertOpen) {
                $('.insert').fadeIn('fast');
                isInsertOpen = true;
            }
        }

        function closeInsert() {
            if (isInsertOpen) {
                $('.insert').fadeOut('fast');
                $('#insert-err').html("");
                isInsertOpen = false;
            }
        }

        function openRemove() {
            if (!isRemoveOpen) {
                $('.remove').fadeIn('fast');
                isRemoveOpen = true;
            }
        }

        function closeRemove() {
            if (isRemoveOpen) {
                $('.remove').fadeOut('fast');
                $('#remove-err').html("");
                isRemoveOpen = false;
            }
        }

        function openSort() {
            if (!isSortOpen) {
                $('.sort').fadeIn('fast');
                isSortOpen = true;
            }
        }

        function closeSort() {
            if (isSortOpen) {
                $('.sort').fadeOut('fast');
                $('#sort-err').html("");
                isSortOpen = false;
            }
        }

        function hideEntireActionsPanel() {
            closeCreate();
            closeInsert();
            closeRemove();
            closeSort();
            hideActionsPanel();
        }
        $(function() {
            AbbreviateTitle();
            hideAllSubmenus();
            var eight_modes = ["Bubble", "Selection", "Insertion", "Merge", "Quick", "RandomizedQuick", "Counting", "Radix"];
            $('#title-'+eight_modes[Math.floor(Math.random()*8)]).click();
            $('#play').hide();
            d3.selectAll("#radix-sort-bucket-labels-collection span")
                .style({"left": function(d, i) {
                    return 17.5 + i * 65 + "px";
                }});
            var sortMode = getQueryVariable("mode");
            if (sortMode.length > 0) {
                $('#title-' + sortMode).click();
            }
            var createArray = getQueryVariable("create");
            if (createArray.length > 0) {
                $('#userdefined-input').val(createArray);
                createList("userdefined");
            }

            $('#create').click(function() {
                closeInsert();
                closeRemove();
                closeSort();
                openCreate();
            });

            $('#insert').click(function() {
                closeCreate();
                closeRemove();
                closeSort();
                openInsert();
            });

            $('#remove').click(function() {
                closeCreate();
                closeInsert();
                closeSort();
                openRemove();
            });

            $('#sort').click(function() {
                closeCreate();
                closeInsert();
                closeRemove();
                openSort();
            });
        });

        var gw = new Sorting();

        const DEFAULT_DATA       = "3,44,38,5,47,15,36,26,27,2,46,4,19,50,48";
        const DEFAULT_COUNT_DATA = "2, 3, 8, 7, 1, 2, 2, 2, 7, 3, 9, 8, 2, 1, 4, 2, 4, 6, 9, 2";
        const DEFAULT_RADIX_DATA = "3221, 1, 10, 9680, 577, 9420, 7, 5622, 4793, 2030, 3138, 82, 2599, 743, 4127";


        function AbbreviateTitle() {
            $('#title-Bubble').text("BUB").attr('title', '冒泡排序');
            $('#title-Selection').text("SEL").attr('title', '选择排序');
            $('#title-Insertion').text("INS").attr('title', '插入排序');
            $('#title-Merge').text("MER").attr('title', '归并排序');
            $('#title-Quick').text("QUI").attr('title', '快速排序');
            $('#title-RandomizedQuick').text("R-Q").attr('title', 'Random Quick Sort');
            $('#title-Counting').text("COU").attr('title', '计数排序');
            $('#title-Radix').text("RAD").attr('title', '基数排序');
        }
        $('#title-Bubble').click(function() {
            showStandardCanvas();
            $("#sort-bubble-merge-inversion").css("display", "");
            $('#current-action p').html('冒泡排序');
            changeSortType(gw.bubbleSort);
            AbbreviateTitle();
            $('#title-Bubble').text('冒泡排序');
        });
        $('#title-Selection').click(function() {
            showStandardCanvas();
            hideAllSortingOptions();
            $('#current-action p').html('选择排序');
            changeSortType(gw.selectionSort);
            AbbreviateTitle();
            $('#title-Selection').text('选择排序');
        });
        $('#title-Insertion').click(function() {
            showStandardCanvas();
            hideAllSortingOptions();
            $('#current-action p').html('插入排序');
            changeSortType(gw.insertionSort);
            AbbreviateTitle();
            $('#title-Insertion').text('插入排序');
        });
        $('#title-Merge').click(function() {
            showStandardCanvas();
            hideAllSortingOptions();
            $("#sort-bubble-merge-inversion").css("display", "");
            $('#current-action p').html('归并排序');
            AbbreviateTitle();
            changeSortType(gw.mergeSort);
            $('#title-Merge').text('归并排序');
        });
        $('#title-Quick').click(function() {
            showStandardCanvas();
            hideAllSortingOptions();
            $('#current-action p').html('快速排序');
            changeSortType(gw.quickSort);
            AbbreviateTitle();
            $('#title-Quick').text('快速排序');
        });
        $('#title-RandomizedQuick').click(function() {
            showStandardCanvas();
            hideAllSortingOptions();
            $('#current-action p').html('Random Quick Sort');
            changeSortType(gw.randomizedQuickSort);
            AbbreviateTitle();
            $('#title-RandomizedQuick').text('Random Quick Sort');
        });
        $('#title-Counting').click(function() {
            showStandardCanvas();
            $("#viz-counting-sort-secondary-canvas").show();
            hideAllSortingOptions();
            $('#current-action p').html('计数排序');
            changeSortType(gw.countingSort, DEFAULT_COUNT_DATA);
            AbbreviateTitle();
            $('#title-Counting').text('计数排序');
        });
        $('#title-Radix').click(function() {
            hideAllCanvases();
            $("#viz-radix-sort-canvas").show();
            hideAllSortingOptions();
            $('#current-action p').html('基数排序');
            changeSortType(gw.radixSort, DEFAULT_RADIX_DATA);
            AbbreviateTitle();
            $('#title-Radix').text('基数排序');
        });

        function changeSortType(newSortingFunction, customNumberList) {
            if (!customNumberList)
                $('#userdefined-input').val(DEFAULT_DATA);
            else
                $('#userdefined-input').val(customNumberList);
            createList('userdefined');

            if (isPlaying) stop();
            showActionsPanel();
            hideStatusPanel();
            hideCodetracePanel();
            gw.clearPseudocode();
            gw.setSelectedSortFunction(newSortingFunction);
        }

        function createList(type) {
            if (isPlaying) stop();
            setTimeout(function() {
                if (gw.createList(type)) {
                    $('#progress-bar').slider("option", "max", 0);
                    closeCreate();
                    isPlaying = false;
                }
            }, 500);
        }

        function sort(callback) {
            gw.computeInversionIndex = $('#sort-bubble-merge-inversion-checkbox').prop('checked');
            if (isPlaying) stop();
            setTimeout(function() {
                if (gw.sort(callback)) {
                    $('#current-action').show();
                    $('#progress-bar').slider("option", "max", gw.getTotalIteration()-1);
                    triggerRightPanels();
                    isPlaying = true;
                }
            }, 500);
        }

        var lastSubmenuShown = null;

        function triggerSubmenu(which) {
            hideAllSubmenus();
            if (lastSubmenuShown == which) {
                lastSubmenuShown = null;
                return;
            }

            lastSubmenuShown = which;

            $(".create").css("bottom", "60px");
            if (which == "sorted") {
                $("#create-sorted-increasing").show();
                $("#create-sorted-decreasing").show();
            }
            else if (which == "nearly-sorted") {
                $("#create-nearly-sorted-increasing").show();
                $("#create-nearly-sorted-decreasing").show();
            }
        }

        function hideAllSubmenus() {
            $(".create").css("bottom", "92px");
            $("#create-sorted-increasing").hide();
            $("#create-sorted-decreasing").hide();
            $("#create-nearly-sorted-increasing").hide();
            $("#create-nearly-sorted-decreasing").hide();
        }

        function hideAllSortingOptions() {
            $("#sort-bubble-merge-inversion").css("display", "none");
        }

        function hideAllCanvases() {
            $("#viz-canvas").hide();
            $("#viz-counting-sort-secondary-canvas").hide();
            $("#viz-radix-sort-canvas").hide();
        }

        function showStandardCanvas() {
            $("#viz-canvas").show();
            $("#viz-counting-sort-secondary-canvas").hide();
            $("#viz-radix-sort-canvas").hide();
        }

        var exploreModeData = [];


        function ENTER_LECTURE_MODE() {
            exploreModeData = gw.currentNumList;
        }


        function ENTER_EXPLORE_MODE() {
            gw.loadNumberList(exploreModeData);
        }

        function SORT(mode) {
            hideSlide(function() {
                sort(showSlide);
            });
        }
        function CUSTOM_ACTION(action, data, mode) {}
    </script>
</div>
</body>
</html>
